# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-11 00:13+0000\n"
"PO-Revision-Date: 2018-05-23 16:10+0000\n"
"Last-Translator: Adrian Liaw <adrianliaw2000@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/signal.rst:2
msgid ":mod:`!signal` --- Set handlers for asynchronous events"
msgstr ":mod:`!signal` --- 設定非同步事件的處理函式"

#: ../../library/signal.rst:7
msgid "**Source code:** :source:`Lib/signal.py`"
msgstr "**原始碼：**\\ :source:`Lib/signal.py`"

#: ../../library/signal.rst:11
msgid "This module provides mechanisms to use signal handlers in Python."
msgstr "本模組提供於 Python 中使用訊號處理程式的機制。"

#: ../../library/signal.rst:15
msgid "General rules"
msgstr "一般規則"

#: ../../library/signal.rst:17
msgid ""
"The :func:`signal.signal` function allows defining custom handlers to be "
"executed when a signal is received.  A small number of default handlers are "
"installed: :const:`SIGPIPE` is ignored (so write errors on pipes and sockets "
"can be reported as ordinary Python exceptions) and :const:`SIGINT` is "
"translated into a :exc:`KeyboardInterrupt` exception if the parent process "
"has not changed it."
msgstr ""
":func:`signal.signal` 函式允許定義自訂的處理程式，會在收到訊號時執行。我們安"
"裝了少數的預設處理程式：:const:`SIGPIPE` 會被忽略 (所以管道和 socket 上的寫入"
"錯誤可以當作一般的 Python 例外報告)，而 :const:`SIGINT`\\ （如果父行程沒有改"
"變它的話）會被轉換成 :exc:`KeyboardInterrupt` 例外。"

#: ../../library/signal.rst:24
msgid ""
"A handler for a particular signal, once set, remains installed until it is "
"explicitly reset (Python emulates the BSD style interface regardless of the "
"underlying implementation), with the exception of the handler for :const:"
"`SIGCHLD`, which follows the underlying implementation."
msgstr ""
"特定訊號的處理程式一旦被設定，就會一直被安裝，直到被明確地重設為止 (不管底層"
"的實作為何，Python 皆模擬出 BSD 風格的介面)，但 :const:`SIGCHLD` 的處理程式除"
"外，它會跟隨底層的實作。"

#: ../../library/signal.rst:29
msgid ""
"On WebAssembly platforms, signals are emulated and therefore behave "
"differently. Several functions and signals are not available on these "
"platforms."
msgstr ""
"在 WebAssembly 平台上，訊號是模擬出來的，故行為不同。有幾個函式和訊號在這些平"
"台上是不可用的。"

#: ../../library/signal.rst:34
msgid "Execution of Python signal handlers"
msgstr "Python 訊號處理程式的執行"

#: ../../library/signal.rst:36
msgid ""
"A Python signal handler does not get executed inside the low-level (C) "
"signal handler.  Instead, the low-level signal handler sets a flag which "
"tells the :term:`virtual machine` to execute the corresponding Python signal "
"handler at a later point(for example at the next :term:`bytecode` "
"instruction). This has consequences:"
msgstr ""
"Python 訊號處理程式不會在低階（C 語言）訊號處理程式中執行。相反地，低階訊號處"
"理程式會設定一個旗標，告訴\\ :term:`虛擬機 <virtual machine>`\\ 在稍後執行相"
"對應的 Python 訊號處理程式（例如在下一個 :term:`bytecode` 指令）。這會有一些"
"後果："

#: ../../library/signal.rst:42
msgid ""
"It makes little sense to catch synchronous errors like :const:`SIGFPE` or :"
"const:`SIGSEGV` that are caused by an invalid operation in C code.  Python "
"will return from the signal handler to the C code, which is likely to raise "
"the same signal again, causing Python to apparently hang.  From Python 3.3 "
"onwards, you can use the :mod:`faulthandler` module to report on synchronous "
"errors."
msgstr ""
"捕捉像 :const:`SIGFPE` 或 :const:`SIGSEGV` 這類由 C 程式碼中無效操作所引起的"
"同步錯誤是沒有意義的。Python 將從訊號處理程式中回傳到 C 程式碼，而 C 程式碼很"
"可能再次引發相同的訊號，導致 Python 明顯假當機 (hang)。從 Python 3.3 開始，你"
"可以使用 :mod:`faulthandler` 模組來報告同步錯誤。"

#: ../../library/signal.rst:49
msgid ""
"A long-running calculation implemented purely in C (such as regular "
"expression matching on a large body of text) may run uninterrupted for an "
"arbitrary amount of time, regardless of any signals received.  The Python "
"signal handlers will be called when the calculation finishes."
msgstr ""
"純粹以 C 實作的長時間計算（例如在大量文字上的正規表示式比對）可能會不間斷地運"
"行任意長度的時間而不考慮收到的任何訊號。當計算完成時，Python 訊號處理程式會被"
"呼叫。"

#: ../../library/signal.rst:54
msgid ""
"If the handler raises an exception, it will be raised \"out of thin air\" in "
"the main thread. See the :ref:`note below <handlers-and-exceptions>` for a "
"discussion."
msgstr ""
"如果處理程式引發例外，就會在主執行緒中「憑空」產生例外。請參閱\\ :ref:`下面的"
"說明 <handlers-and-exceptions>`。"

#: ../../library/signal.rst:62
msgid "Signals and threads"
msgstr "訊號和執行緒"

#: ../../library/signal.rst:64
msgid ""
"Python signal handlers are always executed in the main Python thread of the "
"main interpreter, even if the signal was received in another thread.  This "
"means that signals can't be used as a means of inter-thread communication.  "
"You can use the synchronization primitives from the :mod:`threading` module "
"instead."
msgstr ""
"Python 訊號處理程式總是在主直譯器的主 Python 執行緒中執行，即使訊號是在另一個"
"執行緒中接收到的。這意味著訊號不能用來做為執行緒間通訊的方式。你可以使用 :"
"mod:`threading` 模組的同步原語 (synchronization primitive) 來代替。"

#: ../../library/signal.rst:69
msgid ""
"Besides, only the main thread of the main interpreter is allowed to set a "
"new signal handler."
msgstr "此外，只有主直譯器的主執行緒才被允許設定新的訊號處理程式。"

#: ../../library/signal.rst:73
msgid "Module contents"
msgstr "模組內容"

#: ../../library/signal.rst:75
msgid ""
"signal (SIG*), handler (:const:`SIG_DFL`, :const:`SIG_IGN`) and sigmask (:"
"const:`SIG_BLOCK`, :const:`SIG_UNBLOCK`, :const:`SIG_SETMASK`) related "
"constants listed below were turned into :class:`enums <enum.IntEnum>` (:"
"class:`Signals`, :class:`Handlers` and :class:`Sigmasks` respectively). :"
"func:`getsignal`, :func:`pthread_sigmask`, :func:`sigpending` and :func:"
"`sigwait` functions return human-readable :class:`enums <enum.IntEnum>` as :"
"class:`Signals` objects."
msgstr ""
"下面列出的訊號 (SIG*)、處理器（:const:`SIG_DFL`、:const:`SIG_IGN`）和訊號遮"
"罩 (sigmask)（:const:`SIG_BLOCK`、:const:`SIG_UNBLOCK`、:const:"
"`SIG_SETMASK`）的相關常數被轉換成 :class:`enums <enum.IntEnum>`\\ （:class:"
"`Signals`、:class:`Handlers` 和 :class:`Sigmasks`）。:func:`getsignal`、:"
"func:`pthread_sigmask`、:func:`sigpending` 和 :func:`sigwait` 函式會回傳可被"
"人類閱讀的\\ :class:`枚舉 <enum.IntEnum>`\\ 作為 :class:`Signals` 物件。"

#: ../../library/signal.rst:85
msgid "The signal module defines three enums:"
msgstr "訊號模組定義了三個枚舉："

#: ../../library/signal.rst:89
msgid ""
":class:`enum.IntEnum` collection of SIG* constants and the CTRL_* constants."
msgstr "SIG* 常數和 CTRL_* 常數的 :class:`enum.IntEnum` 集合。"

#: ../../library/signal.rst:95
msgid ""
":class:`enum.IntEnum` collection the constants :const:`SIG_DFL` and :const:"
"`SIG_IGN`."
msgstr ""
":const:`SIG_DFL` 和 :const:`SIG_IGN` 常數的 :class:`enum.IntEnum` 集合。"

#: ../../library/signal.rst:101
msgid ""
":class:`enum.IntEnum` collection the constants :const:`SIG_BLOCK`, :const:"
"`SIG_UNBLOCK` and :const:`SIG_SETMASK`."
msgstr ""
":const:`SIG_BLOCK`、:const:`SIG_UNBLOCK` 和 :const:`SIG_SETMASK` 常數的 :"
"class:`enum.IntEnum` 集合。"

#: ../../library/signal.rst:103 ../../library/signal.rst:136
#: ../../library/signal.rst:142 ../../library/signal.rst:148
#: ../../library/signal.rst:154 ../../library/signal.rst:160
#: ../../library/signal.rst:166 ../../library/signal.rst:180
#: ../../library/signal.rst:198 ../../library/signal.rst:206
#: ../../library/signal.rst:217 ../../library/signal.rst:232
#: ../../library/signal.rst:238 ../../library/signal.rst:244
#: ../../library/signal.rst:262 ../../library/signal.rst:272
#: ../../library/signal.rst:351 ../../library/signal.rst:390
#: ../../library/signal.rst:414 ../../library/signal.rst:437
#: ../../library/signal.rst:471 ../../library/signal.rst:501
#: ../../library/signal.rst:508 ../../library/signal.rst:561
#: ../../library/signal.rst:603 ../../library/signal.rst:618
#: ../../library/signal.rst:644 ../../library/signal.rst:664
msgid "Availability"
msgstr ""

#: ../../library/signal.rst:105 ../../library/signal.rst:473
msgid ""
"See the man page :manpage:`sigprocmask(2)` and :manpage:`pthread_sigmask(3)` "
"for further information."
msgstr ""
"更多資訊請見 :manpage:`sigprocmask(2)` 與 :manpage:`pthread_sigmask(3)` 線上"
"手冊。"

#: ../../library/signal.rst:111
msgid "The variables defined in the :mod:`signal` module are:"
msgstr "在 :mod:`signal` 模組中定義的變數有："

#: ../../library/signal.rst:116
msgid ""
"This is one of two standard signal handling options; it will simply perform "
"the default function for the signal.  For example, on most systems the "
"default action for :const:`SIGQUIT` is to dump core and exit, while the "
"default action for :const:`SIGCHLD` is to simply ignore it."
msgstr ""
"這是兩種標準訊號處理選項之一；它會簡單地執行訊號的預設功能。例如，在大多數系"
"統上，:const:`SIGQUIT` 的預設動作是轉儲 (dump) 核心並退出，而 :const:"
"`SIGCHLD` 的預設動作是直接忽略。"

#: ../../library/signal.rst:124
msgid ""
"This is another standard signal handler, which will simply ignore the given "
"signal."
msgstr "這是另一個標準的訊號處理程式，會直接忽略給定的訊號。"

#: ../../library/signal.rst:130
msgid "Abort signal from :manpage:`abort(3)`."
msgstr "來自 :manpage:`abort(3)` 的中止訊號。"

#: ../../library/signal.rst:134
msgid "Timer signal from :manpage:`alarm(2)`."
msgstr "來自 :manpage:`alarm(2)` 的計時器訊號。"

#: ../../library/signal.rst:140
msgid "Interrupt from keyboard (CTRL + BREAK)."
msgstr "從鍵盤中斷 (CTRL + BREAK)。"

#: ../../library/signal.rst:146
msgid "Bus error (bad memory access)."
msgstr "匯流排錯誤（記憶體存取不良）。"

#: ../../library/signal.rst:152
msgid "Child process stopped or terminated."
msgstr "子行程停止或終止。"

#: ../../library/signal.rst:158
msgid "Alias to :data:`SIGCHLD`."
msgstr ":data:`SIGCHLD` 的別名。"

#: ../../library/signal.rst:164
msgid "Continue the process if it is currently stopped"
msgstr "如果目前行程是被停止的，則繼續運行"

#: ../../library/signal.rst:170
msgid "Floating-point exception. For example, division by zero."
msgstr "浮點運算例外。例如除以零。"

#: ../../library/signal.rst:173
msgid ""
":exc:`ZeroDivisionError` is raised when the second argument of a division or "
"modulo operation is zero."
msgstr ""
":exc:`ZeroDivisionError` 會在除法或模運算 (modulo operation) 的第二個引數為零"
"時引發。"

#: ../../library/signal.rst:178
msgid ""
"Hangup detected on controlling terminal or death of controlling process."
msgstr "偵測到控制終端機掛斷 (hangup) 或控制行程死亡。"

#: ../../library/signal.rst:184
msgid "Illegal instruction."
msgstr "非法指令。"

#: ../../library/signal.rst:188
msgid "Interrupt from keyboard (CTRL + C)."
msgstr "從鍵盤中斷 (CTRL + C)。"

#: ../../library/signal.rst:190
msgid "Default action is to raise :exc:`KeyboardInterrupt`."
msgstr "預設動作是引發 :exc:`KeyboardInterrupt`。"

#: ../../library/signal.rst:194
msgid "Kill signal."
msgstr "殺死訊號。"

#: ../../library/signal.rst:196
msgid "It cannot be caught, blocked, or ignored."
msgstr "它無法被捕捉、阻擋或忽略。"

#: ../../library/signal.rst:202
msgid "Broken pipe: write to pipe with no readers."
msgstr "管道中斷 (broken pipe)：寫到沒有讀取器 (reader) 的管道。"

#: ../../library/signal.rst:204
msgid "Default action is to ignore the signal."
msgstr "預設動作是忽略訊號。"

#: ../../library/signal.rst:210
msgid "Segmentation fault: invalid memory reference."
msgstr "記憶體區段錯誤 (segmentation fault)：無效記憶體參照。"

#: ../../library/signal.rst:214
msgid ""
"Stack fault on coprocessor. The Linux kernel does not raise this signal: it "
"can only be raised in user space."
msgstr ""
"輔助處理器 (coprocessor) 上的堆疊錯誤 (stack fault)。Linux 核心不會引發此訊"
"號：它只能在使用者空間 (user space) 中引發。"

#: ../../library/signal.rst:219
msgid ""
"On architectures where the signal is available. See the man page :manpage:"
"`signal(7)` for further information."
msgstr ""
"在訊號可用的架構上。請參閱 :manpage:`signal(7)` 線上手冊以取得更多資訊。"

#: ../../library/signal.rst:226
msgid "Termination signal."
msgstr "終止訊號。"

#: ../../library/signal.rst:230
msgid "User-defined signal 1."
msgstr "使用者定義訊號 1。"

#: ../../library/signal.rst:236
msgid "User-defined signal 2."
msgstr "使用者定義訊號 2。"

#: ../../library/signal.rst:242
msgid "Window resize signal."
msgstr "視窗調整大小訊號。"

#: ../../library/signal.rst:248
msgid ""
"All the signal numbers are defined symbolically.  For example, the hangup "
"signal is defined as :const:`signal.SIGHUP`; the variable names are "
"identical to the names used in C programs, as found in ``<signal.h>``.  The "
"Unix man page for ':c:func:`signal`' lists the existing signals (on some "
"systems this is :manpage:`signal(2)`, on others the list is in :manpage:"
"`signal(7)`). Note that not all systems define the same set of signal names; "
"only those names defined by the system are defined by this module."
msgstr ""
"所有的訊號編號都是以符號定義的。例如，掛斷訊號被定義為 :const:`signal."
"SIGHUP`；變數名稱與 C 程式中使用的名稱相同，可在 ``<signal.h>`` 中找到。Unix "
"線上手冊 ':c:func:`signal`' 列出了現有的訊號（在某些系統上是 :manpage:"
"`signal(2)`，在其他系統上是在 :manpage:`signal(7)` 中）。請注意，並非所有系統"
"都會定義同一套訊號名稱；只有那些由系統所定義的名稱才會由這個模組定義。"

#: ../../library/signal.rst:259
msgid ""
"The signal corresponding to the :kbd:`Ctrl+C` keystroke event. This signal "
"can only be used with :func:`os.kill`."
msgstr ""
"與 :kbd:`Ctrl+C` 擊鍵 (keystroke) 事件相對應的訊號。此訊號只能與 :func:`os."
"kill` 搭配使用。"

#: ../../library/signal.rst:269
msgid ""
"The signal corresponding to the :kbd:`Ctrl+Break` keystroke event. This "
"signal can only be used with :func:`os.kill`."
msgstr ""
"與 :kbd:`Ctrl+Break` 擊鍵事件相對應的訊號。此訊號只能與 :func:`os.kill` 搭配"
"使用。"

#: ../../library/signal.rst:279
msgid ""
"One more than the number of the highest signal number. Use :func:"
"`valid_signals` to get valid signal numbers."
msgstr ""
"比最高編號訊號的編號多一。使用 :func:`valid_signals` 來取得有效的訊號編號。"

#: ../../library/signal.rst:285
msgid ""
"Decrements interval timer in real time, and delivers :const:`SIGALRM` upon "
"expiration."
msgstr "即時減少間隔計時器 (interval timer)，並在到期時送出 :const:`SIGALRM`。"

#: ../../library/signal.rst:291
msgid ""
"Decrements interval timer only when the process is executing, and delivers "
"SIGVTALRM upon expiration."
msgstr "僅在執行行程時遞減間隔計時器，並在到期時傳送 SIGVTALRM。"

#: ../../library/signal.rst:297
msgid ""
"Decrements interval timer both when the process executes and when the system "
"is executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this "
"timer is usually used to profile the time spent by the application in user "
"and kernel space. SIGPROF is delivered upon expiration."
msgstr ""
"當行程執行或系統代表行程執行時，都會減少間隔計時器。與 ITIMER_VIRTUAL 配合，"
"這個計時器通常用來分析 (profile) 應用程式在使用者空間與核心空間 (kernel "
"space) 所花費的時間。SIGPROF 會在到期時傳送。"

#: ../../library/signal.rst:305
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be blocked."
msgstr ":func:`pthread_sigmask` 的 *how* 參數的可能值，表示訊號將被阻檔。"

#: ../../library/signal.rst:312
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that signals are to be unblocked."
msgstr ":func:`pthread_sigmask` 的 *how* 參數的可能值，表示訊號將被解除阻檔。"

#: ../../library/signal.rst:319
msgid ""
"A possible value for the *how* parameter to :func:`pthread_sigmask` "
"indicating that the signal mask is to be replaced."
msgstr ""
":func:`pthread_sigmask` 的 *how* 參數的可能值，表示訊號遮罩 (signal mask) 要"
"被取代。"

#: ../../library/signal.rst:325
msgid "The :mod:`signal` module defines one exception:"
msgstr ":mod:`signal` 模組定義了一個例外："

#: ../../library/signal.rst:329
msgid ""
"Raised to signal an error from the underlying :func:`setitimer` or :func:"
"`getitimer` implementation. Expect this error if an invalid interval timer "
"or a negative time is passed to :func:`setitimer`. This error is a subtype "
"of :exc:`OSError`."
msgstr ""
"當 :func:`setitimer` 或 :func:`getitimer` 底層實作發生錯誤時引發訊號。如果傳"
"給 :func:`setitimer` 的是無效的間隔計時器或負數時間，則預期會發生此錯誤。這個"
"錯誤是 :exc:`OSError` 的子型別。"

#: ../../library/signal.rst:334
msgid ""
"This error used to be a subtype of :exc:`IOError`, which is now an alias of :"
"exc:`OSError`."
msgstr "此錯誤過去是 :exc:`IOError` 的子型別，現在是 :exc:`OSError` 的別名。"

#: ../../library/signal.rst:339
msgid "The :mod:`signal` module defines the following functions:"
msgstr ":mod:`signal` 模組定義了下列函式："

#: ../../library/signal.rst:344
msgid ""
"If *time* is non-zero, this function requests that a :const:`SIGALRM` signal "
"be sent to the process in *time* seconds. Any previously scheduled alarm is "
"canceled (only one alarm can be scheduled at any time).  The returned value "
"is then the number of seconds before any previously set alarm was to have "
"been delivered. If *time* is zero, no alarm is scheduled, and any scheduled "
"alarm is canceled.  If the return value is zero, no alarm is currently "
"scheduled."
msgstr ""
"如果 *time* 非零，則此函式會要求在 *time* 秒後傳送 :const:`SIGALRM` 訊號給該"
"行程。任何先前排程 (scheduled) 的警報都會被取消（任何時候都只能排程一個警"
"報）。回傳值是先前設定的警報原本再等多久就會被傳送的秒數。如果 *time* 為零，"
"則不會去排程任何警報，且已排程的警報會被取消。如果回傳值為零，則代表目前未排"
"程任何警報。"

#: ../../library/signal.rst:353
msgid "See the man page :manpage:`alarm(2)` for further information."
msgstr "更多資訊請見 :manpage:`alarm(2)` 線上手冊。"

#: ../../library/signal.rst:358
msgid ""
"Return the current signal handler for the signal *signalnum*. The returned "
"value may be a callable Python object, or one of the special values :const:"
"`signal.SIG_IGN`, :const:`signal.SIG_DFL` or :const:`None`.  Here, :const:"
"`signal.SIG_IGN` means that the signal was previously ignored, :const:"
"`signal.SIG_DFL` means that the default way of handling the signal was "
"previously in use, and ``None`` means that the previous signal handler was "
"not installed from Python."
msgstr ""
"回傳訊號 *signalnum* 的目前訊號處理程式。回傳值可以是一個可呼叫的 Python 物"
"件，或是特殊值 :const:`signal.SIG_IGN`、:const:`signal.SIG_DFL` 或 :const:"
"`None` 之一。這裡的 :const:`signal.SIG_IGN` 表示訊號先前被忽略，:const:"
"`signal.SIG_DFL` 表示訊號先前使用預設的處理方式，而 ``None`` 表示先前的訊號處"
"理程式並未從 Python 安裝。"

#: ../../library/signal.rst:369
msgid ""
"Returns the description of signal *signalnum*, such as \"Interrupt\" for :"
"const:`SIGINT`. Returns :const:`None` if *signalnum* has no description. "
"Raises :exc:`ValueError` if *signalnum* is invalid."
msgstr ""
"回傳訊號 *signalnum* 的描述，例如 :const:`SIGINT` 的 \"Interrupt\"。如果 "
"*signalnum* 沒有描述，則回傳 :const:`None`。如果 *signalnum* 無效則會引發 :"
"exc:`ValueError`。"

#: ../../library/signal.rst:378
msgid ""
"Return the set of valid signal numbers on this platform.  This can be less "
"than ``range(1, NSIG)`` if some signals are reserved by the system for "
"internal use."
msgstr ""
"回傳此平台上的有效訊號編號集合。如果某些訊號被系統保留作為內部使用，則此值可"
"能小於 ``range(1, NSIG)``。"

#: ../../library/signal.rst:387
msgid ""
"Cause the process to sleep until a signal is received; the appropriate "
"handler will then be called.  Returns nothing."
msgstr "使行程休眠，直到接收到訊號；然後呼叫適當的處理程式。不會回傳任何東西。"

#: ../../library/signal.rst:392
msgid "See the man page :manpage:`signal(2)` for further information."
msgstr "更多資訊請見 :manpage:`signal(2)` 線上手冊。"

#: ../../library/signal.rst:394
msgid ""
"See also :func:`sigwait`, :func:`sigwaitinfo`, :func:`sigtimedwait` and :"
"func:`sigpending`."
msgstr ""
"也請見 :func:`sigwait`、:func:`sigwaitinfo`、:func:`sigtimedwait` 和 :func:"
"`sigpending`。"

#: ../../library/signal.rst:400
msgid "Sends a signal to the calling process. Returns nothing."
msgstr "傳送訊號至呼叫的行程。不會回傳任何東西。"

#: ../../library/signal.rst:407
msgid ""
"Send signal *sig* to the process referred to by file descriptor *pidfd*. "
"Python does not currently support the *siginfo* parameter; it must be "
"``None``.  The *flags* argument is provided for future extensions; no flag "
"values are currently defined."
msgstr ""
"傳送訊號 *sig* 到檔案描述器 *pidfd* 所指的行程。Python 目前不支援 *siginfo* "
"參數；它必須是 ``None``。*flags* 引數是提供給未來的擴充；目前沒有定義旗標值。"

#: ../../library/signal.rst:412
msgid "See the :manpage:`pidfd_send_signal(2)` man page for more information."
msgstr "更多資訊請見 :manpage:`pidfd_send_signal(2)` 線上手冊。"

#: ../../library/signal.rst:420
msgid ""
"Send the signal *signalnum* to the thread *thread_id*, another thread in the "
"same process as the caller.  The target thread can be executing any code "
"(Python or not).  However, if the target thread is executing the Python "
"interpreter, the Python signal handlers will be :ref:`executed by the main "
"thread of the main interpreter <signals-and-threads>`.  Therefore, the only "
"point of sending a signal to a particular Python thread would be to force a "
"running system call to fail with :exc:`InterruptedError`."
msgstr ""
"將訊號 *signalnum* 傳送給與呼叫者在同一行程中的另一個執行緒 *thread_id*。目標"
"執行緒能執行任何程式碼（無論為 Python 與否）。但是，如果目標執行緒正執行 "
"Python 直譯器，Python 訊號處理程式將會\\ :ref:`由主直譯器的主執行緒來執行 "
"<signals-and-threads>`。因此，向特定 Python 執行緒發送訊號的唯一意義是強制執"
"行中的系統呼叫以 :exc:`InterruptedError` 方式失敗。"

#: ../../library/signal.rst:428
msgid ""
"Use :func:`threading.get_ident` or the :attr:`~threading.Thread.ident` "
"attribute of :class:`threading.Thread` objects to get a suitable value for "
"*thread_id*."
msgstr ""
"使用 :func:`threading.get_ident` 或 :class:`threading.Thread` 物件的 :attr:"
"`~threading.Thread.ident` 屬性來取得 *thread_id* 的適當值。"

#: ../../library/signal.rst:432
msgid ""
"If *signalnum* is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check if the target thread is still running."
msgstr ""
"如果 *signalnum* 為 0，則不會傳送訊號，但仍會執行錯誤檢查；這可用來檢查目標執"
"行緒是否仍在執行。"

#: ../../library/signal.rst:435
msgid ""
"Raises an :ref:`auditing event <auditing>` ``signal.pthread_kill`` with "
"arguments ``thread_id``, ``signalnum``."
msgstr ""
"引發一個附帶引數 ``thread_id``、``signalnum`` 的\\ :ref:`稽核事件 "
"<auditing>` ``signal.pthread_kill``。"

#: ../../library/signal.rst:439
msgid "See the man page :manpage:`pthread_kill(3)` for further  information."
msgstr "更多資訊請見 :manpage:`pthread_kill(3)` 線上手冊。"

#: ../../library/signal.rst:441
msgid "See also :func:`os.kill`."
msgstr "另請參閱 :func:`os.kill`。"

#: ../../library/signal.rst:448
msgid ""
"Fetch and/or change the signal mask of the calling thread.  The signal mask "
"is the set of signals whose delivery is currently blocked for the caller. "
"Return the old signal mask as a set of signals."
msgstr ""
"擷取和/或變更呼叫執行緒的訊號遮罩。訊號遮罩是目前阻擋呼叫者傳送的訊號集合。將"
"舊的訊號遮罩作為一組訊號集合回傳。"

#: ../../library/signal.rst:452
msgid ""
"The behavior of the call is dependent on the value of *how*, as follows."
msgstr "呼叫的行為取決於 *how* 的值，如下所示。"

#: ../../library/signal.rst:454
msgid ""
":data:`SIG_BLOCK`: The set of blocked signals is the union of the current "
"set and the *mask* argument."
msgstr ""
":data:`SIG_BLOCK`：被阻檔的訊號集合是目前訊號集合與 *mask* 引數的聯集。"

#: ../../library/signal.rst:456
msgid ""
":data:`SIG_UNBLOCK`: The signals in *mask* are removed from the current set "
"of blocked signals.  It is permissible to attempt to unblock a signal which "
"is not blocked."
msgstr ""
":data:`SIG_UNBLOCK`：將 *mask* 中的訊號從目前阻檔的訊號集合中移除。嘗試為未被"
"阻檔的訊號解除阻檔是允許的。"

#: ../../library/signal.rst:459
msgid ""
":data:`SIG_SETMASK`: The set of blocked signals is set to the *mask* "
"argument."
msgstr ":data:`SIG_SETMASK`：將被阻檔的訊號集合設定為 *mask* 引數。"

#: ../../library/signal.rst:462
msgid ""
"*mask* is a set of signal numbers (e.g. {:const:`signal.SIGINT`, :const:"
"`signal.SIGTERM`}). Use :func:`~signal.valid_signals` for a full mask "
"including all signals."
msgstr ""
"*mask* 是一組訊號編號（例如 {:const:`signal.SIGINT`, :const:`signal."
"SIGTERM`}）的集合。使用 :func:`~signal.valid_signals` 來取得包含所有訊號的完"
"整遮罩。"

#: ../../library/signal.rst:466
msgid ""
"For example, ``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` reads the "
"signal mask of the calling thread."
msgstr ""
"例如，``signal.pthread_sigmask(signal.SIG_BLOCK, [])`` 會讀取呼叫執行緒的訊號"
"遮罩。"

#: ../../library/signal.rst:469
msgid ":data:`SIGKILL` and :data:`SIGSTOP` cannot be blocked."
msgstr ":data:`SIGKILL` 和 :data:`SIGSTOP` 不能被阻檔。"

#: ../../library/signal.rst:476
msgid "See also :func:`pause`, :func:`sigpending` and :func:`sigwait`."
msgstr "另請參閱 :func:`pause`、:func:`sigpending` 與 :func:`sigwait`。"

#: ../../library/signal.rst:483
msgid ""
"Sets given interval timer (one of :const:`signal.ITIMER_REAL`, :const:"
"`signal.ITIMER_VIRTUAL` or :const:`signal.ITIMER_PROF`) specified by *which* "
"to fire after *seconds* (float is accepted, different from :func:`alarm`) "
"and after that every *interval* seconds (if *interval* is non-zero). The "
"interval timer specified by *which* can be cleared by setting *seconds* to "
"zero."
msgstr ""
"設定由 *which* 指定的間隔計時器（:const:`signal.ITIMER_REAL`、:const:`signal."
"ITIMER_VIRTUAL` 或 :const:`signal.ITIMER_PROF` 之一）並在*seconds*\\ （接受浮"
"點數，與 :func:`alarm` 不同）之後啟動，在之後的每 *interval* 秒啟動一次（如"
"果 *interval* 非零）。*which* 指定的間隔計時器可透過將 *seconds* 設定為零來清"
"除它。"

#: ../../library/signal.rst:490
msgid ""
"When an interval timer fires, a signal is sent to the process. The signal "
"sent is dependent on the timer being used; :const:`signal.ITIMER_REAL` will "
"deliver :const:`SIGALRM`, :const:`signal.ITIMER_VIRTUAL` sends :const:"
"`SIGVTALRM`, and :const:`signal.ITIMER_PROF` will deliver :const:`SIGPROF`."
msgstr ""
"當間隔計時器啟動時，一個訊號會被傳送給行程。傳送的訊號取決於使用的計時器；:"
"const:`signal.ITIMER_REAL` 會傳送 :const:`SIGALRM`，:const:`signal."
"ITIMER_VIRTUAL` 會傳送 :const:`SIGVTALRM`，而 :const:`signal.ITIMER_PROF` 會"
"傳送 :const:`SIGPROF`。"

#: ../../library/signal.rst:496
msgid "The old values are returned as a tuple: (delay, interval)."
msgstr "舊值會以一個元組回傳：(delay, interval)。"

#: ../../library/signal.rst:498
msgid ""
"Attempting to pass an invalid interval timer will cause an :exc:"
"`ItimerError`."
msgstr "嘗試傳入無效的間隔計時器會導致 :exc:`ItimerError`。"

#: ../../library/signal.rst:506
msgid "Returns current value of a given interval timer specified by *which*."
msgstr "回傳由 *which* 指定之間隔計時器的當前值。"

#: ../../library/signal.rst:513
msgid ""
"Set the wakeup file descriptor to *fd*.  When a signal is received, the "
"signal number is written as a single byte into the fd.  This can be used by "
"a library to wakeup a poll or select call, allowing the signal to be fully "
"processed."
msgstr ""
"設定喚醒檔案描述器為 *fd*。當接收到訊號時，訊號編號會以單一位元組寫入 fd。這"
"可被函式庫用來喚醒輪詢 (wakeup a poll) 或 select 呼叫，讓訊號得以完全處理。"

#: ../../library/signal.rst:518
msgid ""
"The old wakeup fd is returned (or -1 if file descriptor wakeup was not "
"enabled).  If *fd* is -1, file descriptor wakeup is disabled. If not -1, "
"*fd* must be non-blocking.  It is up to the library to remove any bytes from "
"*fd* before calling poll or select again."
msgstr ""
"回傳舊的喚醒 fd（如果檔案描述器喚醒未啟用，則回傳 -1）。如果 *fd* 為 -1，則會"
"停用檔案描述器喚醒。如果不是 -1，*fd* 必須是非阻塞的。在再次呼叫輪詢或 "
"select 之前，由函式庫來決定是否移除 *fd* 中的任何位元組。"

#: ../../library/signal.rst:523 ../../library/signal.rst:578
msgid ""
"When threads are enabled, this function can only be called from :ref:`the "
"main thread of the main interpreter <signals-and-threads>`; attempting to "
"call it from other threads will cause a :exc:`ValueError` exception to be "
"raised."
msgstr ""
"當啟用執行緒時，這個函式只能從\\ :ref:`主直譯器 <signals-and-threads>`\\ 的主"
"執行緒來呼叫；嘗試從其他執行緒呼叫它將會引發 :exc:`ValueError` 例外。"

#: ../../library/signal.rst:528
msgid ""
"There are two common ways to use this function. In both approaches, you use "
"the fd to wake up when a signal arrives, but then they differ in how they "
"determine *which* signal or signals have arrived."
msgstr ""
"使用這個函式有兩種常見的方式。在這兩種方法中，當訊號抵達時，你都要使用 fd 來"
"喚醒，但它們的不同之處在於如何判斷\\ *哪個或哪些*\\ 訊號有抵達。"

#: ../../library/signal.rst:533
msgid ""
"In the first approach, we read the data out of the fd's buffer, and the byte "
"values give you the signal numbers. This is simple, but in rare cases it can "
"run into a problem: generally the fd will have a limited amount of buffer "
"space, and if too many signals arrive too quickly, then the buffer may "
"become full, and some signals may be lost. If you use this approach, then "
"you should set ``warn_on_full_buffer=True``, which will at least cause a "
"warning to be printed to stderr when signals are lost."
msgstr ""
"在第一種方法中，我們從 fd 的緩衝區中讀取資料，而位元組值則提供訊號編號。這個"
"方法很簡單，但在少數情況下可能會遇到問題：一般來說，fd 的緩衝區空間有限，如果"
"太多訊號來得太快，那麼緩衝區可能會滿，而有些訊號可能會遺失。如果你使用這種方"
"法，那麼你應該設定 ``warn_on_full_buffer=True``，這至少會在訊號丟失時將警告印"
"出到 stderr。"

#: ../../library/signal.rst:542
msgid ""
"In the second approach, we use the wakeup fd *only* for wakeups, and ignore "
"the actual byte values. In this case, all we care about is whether the fd's "
"buffer is empty or non-empty; a full buffer doesn't indicate a problem at "
"all. If you use this approach, then you should set "
"``warn_on_full_buffer=False``, so that your users are not confused by "
"spurious warning messages."
msgstr ""
"在第二種方法中，我們\\ *只會*\\ 將喚醒 fd 用於喚醒，而忽略實際的位元組值。在"
"這種情況下，我們只在乎 fd 的緩衝區是空或非空；即便緩衝區滿了也不代表有問題。"
"如果你使用這種方法，那麼你應該設定 ``warn_on_full_buffer=False``，這樣你的使"
"用者就不會被虛假的警告訊息所混淆。"

#: ../../library/signal.rst:549
msgid "On Windows, the function now also supports socket handles."
msgstr "在 Windows 上，此功能現在也支援 socket 處理程式。"

#: ../../library/signal.rst:552
msgid "Added ``warn_on_full_buffer`` parameter."
msgstr "新增 ``warn_on_full_buffer`` 參數。"

#: ../../library/signal.rst:557
msgid ""
"Change system call restart behaviour: if *flag* is :const:`False`, system "
"calls will be restarted when interrupted by signal *signalnum*, otherwise "
"system calls will be interrupted.  Returns nothing."
msgstr ""
"改變系統呼叫重新啟動的行為：如果 *flag* 是 :const:`False`，系統呼叫會在被訊"
"號 *signalnum* 中斷時重新啟動，否則系統呼叫會被中斷。不會回傳任何東西。"

#: ../../library/signal.rst:563
msgid "See the man page :manpage:`siginterrupt(3)` for further information."
msgstr "更多資訊請見 :manpage:`siginterrupt(3)` 線上手冊。"

#: ../../library/signal.rst:565
msgid ""
"Note that installing a signal handler with :func:`signal` will reset the "
"restart behaviour to interruptible by implicitly calling :c:func:`!"
"siginterrupt` with a true *flag* value for the given signal."
msgstr ""
"請注意，使用 :func:`signal` 安裝訊號處理程式，會透過隱式呼叫 :c:func:`!"
"siginterrupt` 來將重新啟動的行為重設為可中斷，且指定訊號的 *flag* 值為 true。"

#: ../../library/signal.rst:572
msgid ""
"Set the handler for signal *signalnum* to the function *handler*.  *handler* "
"can be a callable Python object taking two arguments (see below), or one of "
"the special values :const:`signal.SIG_IGN` or :const:`signal.SIG_DFL`.  The "
"previous signal handler will be returned (see the description of :func:"
"`getsignal` above).  (See the Unix man page :manpage:`signal(2)` for further "
"information.)"
msgstr ""
"將訊號 *signalnum* 的處理程式設定為函式 *handler*。*handler* 可以是帶兩個引數"
"的可呼叫 Python 物件（見下面），或是特殊值 :const:`signal.SIG_IGN` 或 :const:"
"`signal.SIG_DFL` 之一。先前的訊號處理程式將會被回傳（請參閱上面 :func:"
"`getsignal` 的說明）。（更多資訊請參閱 Unix 線上手冊 :`signal(2)`）。"

#: ../../library/signal.rst:583
msgid ""
"The *handler* is called with two arguments: the signal number and the "
"current stack frame (``None`` or a frame object; for a description of frame "
"objects, see the :ref:`description in the type hierarchy <frame-objects>` or "
"see the attribute descriptions in the :mod:`inspect` module)."
msgstr ""
"*handler* 被呼叫時有兩個引數：訊號編號和目前的堆疊 frame（``None`` 或一個 "
"frame 物件；關於 frame 物件的描述，請參閱\\ :ref:`型別階層中的描述 <frame-"
"objects>`\\ 或 :mod:`inspect` 模組中的屬性描述）。"

#: ../../library/signal.rst:588
msgid ""
"On Windows, :func:`signal` can only be called with :const:`SIGABRT`, :const:"
"`SIGFPE`, :const:`SIGILL`, :const:`SIGINT`, :const:`SIGSEGV`, :const:"
"`SIGTERM`, or :const:`SIGBREAK`. A :exc:`ValueError` will be raised in any "
"other case. Note that not all systems define the same set of signal names; "
"an :exc:`AttributeError` will be raised if a signal name is not defined as "
"``SIG*`` module level constant."
msgstr ""
"在 Windows 上，:func:`signal` 只能在使用 :const:`SIGABRT`、:const:`SIGFPE`、:"
"const:`SIGILL`、:const:`SIGINT`、:const:`SIGSEGV`、:const:`SIGTERM` 或 :"
"const:`SIGBREAK` 時呼叫。在其他情況下會引發 :exc:`ValueError`。請注意，並非所"
"有系統都定義相同的訊號名稱；如果訊號名稱沒有被定義為 ``SIG*`` 模組層級常數，"
"則會引發 :exc:`AttributeError` 錯誤。"

#: ../../library/signal.rst:599
msgid ""
"Examine the set of signals that are pending for delivery to the calling "
"thread (i.e., the signals which have been raised while blocked).  Return the "
"set of the pending signals."
msgstr ""
"檢查待傳送至呼叫執行緒的訊號集合（即阻檔時已被提出的訊號）。回傳待定訊號的集"
"合。"

#: ../../library/signal.rst:605
msgid "See the man page :manpage:`sigpending(2)` for further information."
msgstr "更多資訊請見 :manpage:`sigpending(2)` 線上手冊。"

#: ../../library/signal.rst:607
msgid "See also :func:`pause`, :func:`pthread_sigmask` and :func:`sigwait`."
msgstr "另請參閱 :func:`pause`、:func:`pthread_sigmask` 與 :func:`sigwait`。"

#: ../../library/signal.rst:614
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal (removes it from the pending list of signals), and returns the signal "
"number."
msgstr ""
"暫停呼叫執行緒的執行，直到送出訊號集合 *sigset* 中指定的一個訊號。函式接受訊"
"號（將其從待定訊號清單中移除），並回傳訊號編號。"

#: ../../library/signal.rst:620
msgid "See the man page :manpage:`sigwait(3)` for further information."
msgstr "更多資訊請見 :manpage:`sigwait(3)` 線上手冊。"

#: ../../library/signal.rst:622
msgid ""
"See also :func:`pause`, :func:`pthread_sigmask`, :func:`sigpending`, :func:"
"`sigwaitinfo` and :func:`sigtimedwait`."
msgstr ""
"另也請見 :func:`pause`、:func:`pthread_sigmask`、:func:`sigpending`、:func:"
"`sigwaitinfo` 和 :func:`sigtimedwait`。"

#: ../../library/signal.rst:630
msgid ""
"Suspend execution of the calling thread until the delivery of one of the "
"signals specified in the signal set *sigset*.  The function accepts the "
"signal and removes it from the pending list of signals. If one of the "
"signals in *sigset* is already pending for the calling thread, the function "
"will return immediately with information about that signal. The signal "
"handler is not called for the delivered signal. The function raises an :exc:"
"`InterruptedError` if it is interrupted by a signal that is not in *sigset*."
msgstr ""
"暫停呼叫執行緒的執行，直到送出訊號集合 *sigset* 中指定的一個訊號。該函式接受"
"訊號，並將其從待定訊號清單中移除。如果 *sigset* 中的一個訊號已經是呼叫執行緒"
"的待定訊號，函式會立即回傳該訊號的相關資訊。對於已傳送的訊號，訊號處理程式不"
"會被呼叫。如果被不在 *sigset* 中的訊號中斷，函式會引發 :exc:"
"`InterruptedError`。"

#: ../../library/signal.rst:639
msgid ""
"The return value is an object representing the data contained in the :c:type:"
"`siginfo_t` structure, namely: :attr:`si_signo`, :attr:`si_code`, :attr:"
"`si_errno`, :attr:`si_pid`, :attr:`si_uid`, :attr:`si_status`, :attr:"
"`si_band`."
msgstr ""
"回傳值是一個物件，代表 :c:type:`siginfo_t` 結構所包含的資料，即 :attr:"
"`si_signo`、:attr:`si_code`、:attr:`si_errno`、:attr:`si_pid`、:attr:"
"`si_uid`、:attr:`si_status`、:attr:`si_band`。"

#: ../../library/signal.rst:646
msgid "See the man page :manpage:`sigwaitinfo(2)` for further information."
msgstr "更多資訊請見 :manpage:`sigwaitinfo(2)` 線上手冊。"

#: ../../library/signal.rst:648
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigtimedwait`."
msgstr "另請參閱 :func:`pause`、:func:`sigwait` 與 :func:`sigtimedwait`。"

#: ../../library/signal.rst:652
msgid ""
"The function is now retried if interrupted by a signal not in *sigset* and "
"the signal handler does not raise an exception (see :pep:`475` for the "
"rationale)."
msgstr ""
"現在如果被不在 *sigset* 中的訊號中斷，且訊號處理程式沒有引發例外，則會重試函"
"式（理由請參閱 :pep:`475`）。"

#: ../../library/signal.rst:660
msgid ""
"Like :func:`sigwaitinfo`, but takes an additional *timeout* argument "
"specifying a timeout. If *timeout* is specified as ``0``, a poll is "
"performed. Returns :const:`None` if a timeout occurs."
msgstr ""
"類似 :func:`sigwaitinfo`，但需要額外的 *timeout* 引數指定逾時時間。如果 "
"*timeout* 指定為 ``0``，會執行輪詢。如果發生逾時則會回傳 :const:`None`。"

#: ../../library/signal.rst:666
msgid "See the man page :manpage:`sigtimedwait(2)` for further information."
msgstr "更多資訊請見 :manpage:`sigtimedwait(2)` 線上手冊。"

#: ../../library/signal.rst:668
msgid "See also :func:`pause`, :func:`sigwait` and :func:`sigwaitinfo`."
msgstr "另請參閱 :func:`pause`、:func:`sigwait` 與 :func:`sigwaitinfo`。"

#: ../../library/signal.rst:672
msgid ""
"The function is now retried with the recomputed *timeout* if interrupted by "
"a signal not in *sigset* and the signal handler does not raise an exception "
"(see :pep:`475` for the rationale)."
msgstr ""
"現在如果被不在 *sigset* 中的訊號中斷，且訊號處理程式沒有引發例外，則會使用重"
"新計算的 *timeout* 重試函式（理由請參閱 :pep:`475`）。"

#: ../../library/signal.rst:681
msgid "Examples"
msgstr "範例"

#: ../../library/signal.rst:683
msgid ""
"Here is a minimal example program. It uses the :func:`alarm` function to "
"limit the time spent waiting to open a file; this is useful if the file is "
"for a serial device that may not be turned on, which would normally cause "
"the :func:`os.open` to hang indefinitely.  The solution is to set a 5-second "
"alarm before opening the file; if the operation takes too long, the alarm "
"signal will be sent, and the handler raises an exception. ::"
msgstr ""
"這是一個最小範例程式。它使用 :func:`alarm` 函式來限制等待開啟檔案的時間；如果"
"檔案是用於可能未開啟的序列裝置，這會很有用，因為這通常會導致 :func:`os.open` "
"無限期地被擱置。解決方法是在開啟檔案前設定一個 5 秒的警報；如果操作時間過長，"
"警報訊號就會被送出，而處理程式會產生例外。 ::"

#: ../../library/signal.rst:690
msgid ""
"import signal, os\n"
"\n"
"def handler(signum, frame):\n"
"    signame = signal.Signals(signum).name\n"
"    print(f'Signal handler called with signal {signame} ({signum})')\n"
"    raise OSError(\"Couldn't open device!\")\n"
"\n"
"# Set the signal handler and a 5-second alarm\n"
"signal.signal(signal.SIGALRM, handler)\n"
"signal.alarm(5)\n"
"\n"
"# This open() may hang indefinitely\n"
"fd = os.open('/dev/ttyS0', os.O_RDWR)\n"
"\n"
"signal.alarm(0)          # Disable the alarm"
msgstr ""
"import signal, os\n"
"\n"
"def handler(signum, frame):\n"
"    signame = signal.Signals(signum).name\n"
"    print(f'Signal handler called with signal {signame} ({signum})')\n"
"    raise OSError(\"Couldn't open device!\")\n"
"\n"
"# 設定訊號處理程式與五秒警報\n"
"signal.signal(signal.SIGALRM, handler)\n"
"signal.alarm(5)\n"
"\n"
"# 這個 open() 可能無限期地被擱置\n"
"fd = os.open('/dev/ttyS0', os.O_RDWR)\n"
"\n"
"signal.alarm(0)          # 停用警報"

#: ../../library/signal.rst:707
msgid "Note on SIGPIPE"
msgstr "關於 SIGPIPE 的說明"

#: ../../library/signal.rst:709
msgid ""
"Piping output of your program to tools like :manpage:`head(1)` will cause a :"
"const:`SIGPIPE` signal to be sent to your process when the receiver of its "
"standard output closes early.  This results in an exception like :code:"
"`BrokenPipeError: [Errno 32] Broken pipe`.  To handle this case, wrap your "
"entry point to catch this exception as follows::"
msgstr ""
"將程式的輸出管道化到 :manpage:`head(1)` 之類的工具，會在你的行程的標準輸出接"
"收器提早關閉時，導致 :const:`SIGPIPE` 訊號傳送給你的行程。這會導致類似 :code:"
"`BrokenPipeError: [Errno 32] Broken pipe` 的例外。要處理這種情況，請將你的進"
"入點包裝成如下的樣子來捕捉這個例外： ::"

#: ../../library/signal.rst:715
msgid ""
"import os\n"
"import sys\n"
"\n"
"def main():\n"
"    try:\n"
"        # simulate large output (your code replaces this loop)\n"
"        for x in range(10000):\n"
"            print(\"y\")\n"
"        # flush output here to force SIGPIPE to be triggered\n"
"        # while inside this try block.\n"
"        sys.stdout.flush()\n"
"    except BrokenPipeError:\n"
"        # Python flushes standard streams on exit; redirect remaining "
"output\n"
"        # to devnull to avoid another BrokenPipeError at shutdown\n"
"        devnull = os.open(os.devnull, os.O_WRONLY)\n"
"        os.dup2(devnull, sys.stdout.fileno())\n"
"        sys.exit(1)  # Python exits with error code 1 on EPIPE\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""
"import os\n"
"import sys\n"
"\n"
"def main():\n"
"    try:\n"
"        # 模擬大量輸出（你的程式取代此迴圈）\n"
"        for x in range(10000):\n"
"            print(\"y\")\n"
"        # 在這裡清除輸出以強制 SIGPIPE 在這個 try 區塊\n"
"        # 中被觸發\n"
"        sys.stdout.flush()\n"
"    except BrokenPipeError:\n"
"        # Python 在退出時清除標準串流；為剩下的輸出重新導向\n"
"        # 至 devnull 來避免關閉時的 BrokenPipeError\n"
"        devnull = os.open(os.devnull, os.O_WRONLY)\n"
"        os.dup2(devnull, sys.stdout.fileno())\n"
"        sys.exit(1)  # Python 在 EPIPE 時以錯誤碼 1 退出\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"

#: ../../library/signal.rst:736
msgid ""
"Do not set :const:`SIGPIPE`'s disposition to :const:`SIG_DFL` in order to "
"avoid :exc:`BrokenPipeError`.  Doing that would cause your program to exit "
"unexpectedly whenever any socket connection is interrupted while your "
"program is still writing to it."
msgstr ""
"不要為了避免 :exc:`BrokenPipeError` 而將 :const:`SIGPIPE` 之處置 "
"(disposition) 設定為 :const:`SIG_DFL`。這樣做會導致你的程式在寫入任何 socket "
"連線時被中斷而意外退出。"

#: ../../library/signal.rst:745
msgid "Note on Signal Handlers and Exceptions"
msgstr "訊號處理程式與例外的說明"

#: ../../library/signal.rst:747
msgid ""
"If a signal handler raises an exception, the exception will be propagated to "
"the main thread and may be raised after any :term:`bytecode` instruction. "
"Most notably, a :exc:`KeyboardInterrupt` may appear at any point during "
"execution. Most Python code, including the standard library, cannot be made "
"robust against this, and so a :exc:`KeyboardInterrupt` (or any other "
"exception resulting from a signal handler) may on rare occasions put the "
"program in an unexpected state."
msgstr ""
"如果訊號處理程式產生例外，例外會傳送到主執行緒並可能在任何 :term:`bytecode` "
"指令之後發生。最值得注意的是，:exc:`KeyboardInterrupt` 可能在執行過程中的任何"
"時候出現。大多數 Python 程式碼，包括標準函式庫，都無法避免這種情況，因此 :"
"exc:`KeyboardInterrupt`\\ （或任何其他由訊號處理程式產生的例外）可能會在罕見"
"的情況下使程式處於預期之外的狀態。"

#: ../../library/signal.rst:754
msgid "To illustrate this issue, consider the following code::"
msgstr "為了說明這個問題，請參考以下程式碼： ::"

#: ../../library/signal.rst:756
msgid ""
"class SpamContext:\n"
"    def __init__(self):\n"
"        self.lock = threading.Lock()\n"
"\n"
"    def __enter__(self):\n"
"        # If KeyboardInterrupt occurs here, everything is fine\n"
"        self.lock.acquire()\n"
"        # If KeyboardInterrupt occurs here, __exit__ will not be called\n"
"        ...\n"
"        # KeyboardInterrupt could occur just before the function returns\n"
"\n"
"    def __exit__(self, exc_type, exc_val, exc_tb):\n"
"        ...\n"
"        self.lock.release()"
msgstr ""
"class SpamContext:\n"
"    def __init__(self):\n"
"        self.lock = threading.Lock()\n"
"\n"
"    def __enter__(self):\n"
"        # 如果 KeyboardInterrupt 在此發生則一切正常\n"
"        self.lock.acquire()\n"
"        # 如果 KeyboardInterrupt 在此發生，__exit__ 將不會被呼叫\n"
"        ...\n"
"        # KeyboardInterrupt 可能在函式回傳之前發生\n"
"\n"
"    def __exit__(self, exc_type, exc_val, exc_tb):\n"
"        ...\n"
"        self.lock.release()"

#: ../../library/signal.rst:771
msgid ""
"For many programs, especially those that merely want to exit on :exc:"
"`KeyboardInterrupt`, this is not a problem, but applications that are "
"complex or require high reliability should avoid raising exceptions from "
"signal handlers. They should also avoid catching :exc:`KeyboardInterrupt` as "
"a means of gracefully shutting down.  Instead, they should install their "
"own :const:`SIGINT` handler. Below is an example of an HTTP server that "
"avoids :exc:`KeyboardInterrupt`::"
msgstr ""
"對許多程式來說，尤其是那些只想在 :exc:`KeyboardInterrupt` 時退出的程式，這並"
"不是問題，但是對於複雜或需要高可靠性的應用程式來說，應該避免從訊號處理程式產"
"生例外。它們也應該避免將捕獲 :exc:`KeyboardInterrupt` 作為一種優雅關閉 "
"(gracefully shutting down) 的方式。相反地，它們應該安裝自己的 :const:"
"`SIGINT` 處理程式。以下是 HTTP 伺服器避免 :exc:`KeyboardInterrupt` 的範"
"例： ::"

#: ../../library/signal.rst:779
msgid ""
"import signal\n"
"import socket\n"
"from selectors import DefaultSelector, EVENT_READ\n"
"from http.server import HTTPServer, SimpleHTTPRequestHandler\n"
"\n"
"interrupt_read, interrupt_write = socket.socketpair()\n"
"\n"
"def handler(signum, frame):\n"
"    print('Signal handler called with signal', signum)\n"
"    interrupt_write.send(b'\\0')\n"
"signal.signal(signal.SIGINT, handler)\n"
"\n"
"def serve_forever(httpd):\n"
"    sel = DefaultSelector()\n"
"    sel.register(interrupt_read, EVENT_READ)\n"
"    sel.register(httpd, EVENT_READ)\n"
"\n"
"    while True:\n"
"        for key, _ in sel.select():\n"
"            if key.fileobj == interrupt_read:\n"
"                interrupt_read.recv(1)\n"
"                return\n"
"            if key.fileobj == httpd:\n"
"                httpd.handle_request()\n"
"\n"
"print(\"Serving on port 8000\")\n"
"httpd = HTTPServer(('', 8000), SimpleHTTPRequestHandler)\n"
"serve_forever(httpd)\n"
"print(\"Shutdown...\")"
msgstr ""
"import signal\n"
"import socket\n"
"from selectors import DefaultSelector, EVENT_READ\n"
"from http.server import HTTPServer, SimpleHTTPRequestHandler\n"
"\n"
"interrupt_read, interrupt_write = socket.socketpair()\n"
"\n"
"def handler(signum, frame):\n"
"    print('Signal handler called with signal', signum)\n"
"    interrupt_write.send(b'\\0')\n"
"signal.signal(signal.SIGINT, handler)\n"
"\n"
"def serve_forever(httpd):\n"
"    sel = DefaultSelector()\n"
"    sel.register(interrupt_read, EVENT_READ)\n"
"    sel.register(httpd, EVENT_READ)\n"
"\n"
"    while True:\n"
"        for key, _ in sel.select():\n"
"            if key.fileobj == interrupt_read:\n"
"                interrupt_read.recv(1)\n"
"                return\n"
"            if key.fileobj == httpd:\n"
"                httpd.handle_request()\n"
"\n"
"print(\"Serving on port 8000\")\n"
"httpd = HTTPServer(('', 8000), SimpleHTTPRequestHandler)\n"
"serve_forever(httpd)\n"
"print(\"Shutdown...\")"
