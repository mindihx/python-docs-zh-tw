# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Matt Wang <mattwang44@gmail.com>, 2024
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-15 00:13+0000\n"
"PO-Revision-Date: 2024-10-19 17:39+0800\n"
"Last-Translator: Matt Wang <mattwang44@gmail.com>\n"
"Language-Team: Chinese - TAIWAN (https://github.com/python/python-docs-zh-"
"tw)\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/pdb.rst:4
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- Python 偵錯器"

#: ../../library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**原始碼：**\\ :source:`Lib/pdb.py`"

#: ../../library/pdb.rst:15
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for Python "
"programs.  It supports setting (conditional) breakpoints and single stepping "
"at the source line level, inspection of stack frames, source code listing, "
"and evaluation of arbitrary Python code in the context of any stack frame.  "
"It also supports post-mortem debugging and can be called under program "
"control."
msgstr ""
":mod:`pdb` 模組定義了一個 Python 程式的互動式原始碼偵錯器。它支援在原始碼列層"
"級 (source line level) 設定（條件式的）斷點 (breakpoint) 和單步執行、檢視 "
"stack frame（堆疊框）、列出原始碼、以及在任何 stack frame 情境 (context) 中為"
"任意 Python 程式碼求值 (evaluation)。它還支援事後偵錯 (post-mortem "
"debugging)，並可以在程式控制下呼叫。"

#: ../../library/pdb.rst:26
msgid ""
"The debugger is extensible -- it is actually defined as the "
"class :class:`Pdb`. This is currently undocumented but easily understood by "
"reading the source.  The extension interface uses the modules :mod:`bdb` "
"and :mod:`cmd`."
msgstr ""
"偵錯器是可擴充的 —— 偵錯器實際被定義為 :class:`Pdb` 類別。該類別目前沒有文"
"件，但可以很容易地透過閱讀原始碼來理解它。擴充套件介面使用了 :mod:`bdb` "
"和 :mod:`cmd` 模組。"

#: ../../library/pdb.rst:32
msgid "Module :mod:`faulthandler`"
msgstr ":mod:`faulthandler` 模組"

#: ../../library/pdb.rst:33
msgid ""
"Used to dump Python tracebacks explicitly, on a fault, after a timeout, or "
"on a user signal."
msgstr ""
"用於在出現故障時、超時 (timeout) 後或於接收到使用者訊號時，顯式地轉儲 (dump) "
"Python 回溯 (traceback)。"

#: ../../library/pdb.rst:36
msgid "Module :mod:`traceback`"
msgstr ":mod:`traceback` 模組"

#: ../../library/pdb.rst:37
msgid ""
"Standard interface to extract, format and print stack traces of Python "
"programs."
msgstr "用於提取、格式化和印出 Python 程式 stack trace（堆疊追蹤）的標準介面。"

#: ../../library/pdb.rst:39
msgid "The typical usage to break into the debugger is to insert::"
msgstr "自一個執行中程式切入偵錯器的典型用法為插入： ::"

#: ../../library/pdb.rst:41
msgid "import pdb; pdb.set_trace()"
msgstr "import pdb; pdb.set_trace()"

#: ../../library/pdb.rst:43
msgid "Or::"
msgstr "或： ::"

#: ../../library/pdb.rst:45
msgid "breakpoint()"
msgstr "breakpoint()"

#: ../../library/pdb.rst:47
msgid ""
"at the location you want to break into the debugger, and then run the "
"program. You can then step through the code following this statement, and "
"continue running without the debugger using the :pdbcmd:`continue` command."
msgstr ""
"到你想切入偵錯器的位置，然後執行程式，就可以單步執行上述陳述式之後的程式碼，"
"並可以使用 :pdbcmd:`continue` 命令來離開偵錯器、繼續執行。"

#: ../../library/pdb.rst:51
msgid ""
"The built-in :func:`breakpoint`, when called with defaults, can be used "
"instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"當使用預設值呼叫時，可以使用內建的 :func:`breakpoint` 來取代 ``import pdb; "
"pdb.set_trace()``。"

#: ../../library/pdb.rst:57
msgid ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"
msgstr ""
"def double(x):\n"
"   breakpoint()\n"
"   return x * 2\n"
"val = 3\n"
"print(f\"{val} * 2 is {double(val)}\")"

#: ../../library/pdb.rst:63
msgid ""
"The debugger's prompt is ``(Pdb)``, which is the indicator that you are in "
"debug mode::"
msgstr "偵錯器的提示字元是 ``(Pdb)``，這表示你處於偵錯模式： ::"

#: ../../library/pdb.rst:65
msgid ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"
msgstr ""
"> ...(2)double()\n"
"-> breakpoint()\n"
"(Pdb) p x\n"
"3\n"
"(Pdb) continue\n"
"3 * 2 is 6"

#: ../../library/pdb.rst:72
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands and "
"command arguments, e.g. the current global and local names are offered as "
"arguments of the ``p`` command."
msgstr ""
"透過 :mod:`readline` 模組達成的 tab 補全可用於補全本模組的命令和命令的引數，"
"例如會提供當前的全域和區域名稱以作為 ``p`` 命令的引數。"

#: ../../library/pdb.rst:78
msgid ""
"You can also invoke :mod:`pdb` from the command line to debug other "
"scripts.  For example::"
msgstr "你還可以從命令列調用 :mod:`pdb` 來偵錯其他腳本。例如： ::"

#: ../../library/pdb.rst:81
msgid "python -m pdb myscript.py"
msgstr "python -m pdb myscript.py"

#: ../../library/pdb.rst:83
msgid ""
"When invoked as a module, pdb will automatically enter post-mortem debugging "
"if the program being debugged exits abnormally.  After post-mortem debugging "
"(or after normal exit of the program), pdb will restart the program.  "
"Automatic restarting preserves pdb's state (such as breakpoints) and in most "
"cases is more useful than quitting the debugger upon program's exit."
msgstr ""
"當作為模組調用時，如果被偵錯的程序不正常地退出，pdb 將自動進入事後偵錯。事後"
"偵錯後（或程式正常退出後），pdb 將重新啟動程式。自動重新啟動會保留 pdb 的狀態"
"（例如斷點），並且在大多數情況下比在程式退出時退出偵錯器更有用。"

#: ../../library/pdb.rst:89
msgid ""
"Added the ``-c`` option to execute commands as if given in a :file:`.pdbrc` "
"file; see :ref:`debugger-commands`."
msgstr ""
"新增了 ``-c`` 選項來執行命令，就像能在 :file:`.pdbrc` 檔案中給定的那樣；請參"
"閱\\ :ref:`偵錯器命令 <debugger-commands>`。"

#: ../../library/pdb.rst:93
msgid ""
"Added the ``-m`` option to execute modules similar to the way ``python -m`` "
"does. As with a script, the debugger will pause execution just before the "
"first line of the module."
msgstr ""
"新增了 ``-m`` 選項以類似於 ``python -m`` 的方式來執行模組。與腳本一樣，偵錯器"
"將在模組的第一列之前暫停執行。"

#: ../../library/pdb.rst:98
msgid "Typical usage to execute a statement under control of the debugger is::"
msgstr "在偵錯器控制下執行陳述式的典型用法是： ::"

#: ../../library/pdb.rst:100
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
">>> pdb.run(\"f(2)\")\n"
"> <string>(1)<module>()\n"
"(Pdb) continue\n"
"0.5\n"
">>>"

#: ../../library/pdb.rst:109
msgid "The typical usage to inspect a crashed program is::"
msgstr "檢查一個損壞程式的典型用法： ::"

#: ../../library/pdb.rst:111
msgid ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"
msgstr ""
">>> import pdb\n"
">>> def f(x):\n"
"...     print(1 / x)\n"
"...\n"
">>> f(0)\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"  File \"<stdin>\", line 2, in f\n"
"ZeroDivisionError: division by zero\n"
">>> pdb.pm()\n"
"> <stdin>(2)f()\n"
"(Pdb) p x\n"
"0\n"
"(Pdb)"

#: ../../library/pdb.rst:126
msgid ""
"The implementation of :pep:`667` means that name assignments made via "
"``pdb`` will immediately affect the active scope, even when running inside "
"an :term:`optimized scope`."
msgstr ""
":pep:`667` 的實作意味著透過 ``pdb`` 進行的名稱賦予 (name assignments) 會立即"
"影響有效作用域，即使在\\ :term:`最佳化作用域 <optimized scope>`\\ 內運作也是"
"如此。"

#: ../../library/pdb.rst:132
msgid ""
"The module defines the following functions; each enters the debugger in a "
"slightly different way:"
msgstr "本模組定義了下列函式，每個函式進入偵錯器的方式略有不同："

#: ../../library/pdb.rst:137
msgid ""
"Execute the *statement* (given as a string or a code object) under debugger "
"control.  The debugger prompt appears before any code is executed; you can "
"set breakpoints and type :pdbcmd:`continue`, or you can step through the "
"statement using :pdbcmd:`step` or :pdbcmd:`next` (all these commands are "
"explained below).  The optional *globals* and *locals* arguments specify the "
"environment in which the code is executed; by default the dictionary of the "
"module :mod:`__main__` is used.  (See the explanation of the built-"
"in :func:`exec` or :func:`eval` functions.)"
msgstr ""
"在偵錯器控制下執行 *statement*\\ （以字串或程式碼物件形式給定）。偵錯提示字元"
"會在執行任何程式碼前出現；你可以設定斷點並輸入 :pdbcmd:`continue`，或也可以使"
"用 :pdbcmd:`step` 或 :pdbcmd:`next` 逐步執行陳述式（這些命令在下面都有說"
"明）。可選引數 *globals* 和 *locals* 指定程式碼執行的環境；預設使"
"用 :mod:`__main__` 模組的字典。（請參閱內建函式 :func:`exec` 或 :func:`eval` "
"的說明。）"

#: ../../library/pdb.rst:149
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of the "
"*expression*.  Otherwise this function is similar to :func:`run`."
msgstr ""
"在偵錯器控制下為 *expression* 求值（以字串或程式碼物件形式給定）。"
"當 :func:`runeval` 回傳時，它回傳 *expression* 的值。除此之外，該函式"
"與 :func:`run` 類似。"

#: ../../library/pdb.rst:156
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the function "
"is entered."
msgstr ""
"使用給定的引數呼叫 *function*\\ （只可以是函式或方法物件，不能是字"
"串）。:func:`runcall` 回傳的是所呼叫函式的回傳值。偵錯器提示字元將在進入函式"
"後立即出現。"

#: ../../library/pdb.rst:164
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-code "
"a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, *header* "
"is printed to the console just before debugging begins."
msgstr ""
"在呼叫此函式的 stack frame 進入偵錯器。用於在程式中給定之處寫死 (hard-code) "
"一個斷點，即便該程式碼不在偵錯狀態（如斷言失敗時）。如有給定 *header*，它將在"
"偵錯正要開始前被印出到控制台。"

#: ../../library/pdb.rst:169
msgid "The keyword-only argument *header*."
msgstr "僅限關鍵字引數 *header*。"

#: ../../library/pdb.rst:172
msgid ""
":func:`set_trace` will enter the debugger immediately, rather than on the "
"next line of code to be executed."
msgstr ":func:`set_trace` 將立即進入偵錯器，而不是在下一列要執行的程式碼中。"

#: ../../library/pdb.rst:178
msgid ""
"Enter post-mortem debugging of the given exception or :ref:`traceback object "
"<traceback-objects>`. If no value is given, it uses the exception that is "
"currently being handled, or raises ``ValueError`` if there isn’t one."
msgstr ""
"進入所給定例外或\\ :ref:`回溯物件 <traceback-objects>`\\ 的事後偵錯。如果沒有"
"給定，預設使用當前正在處理的例外，或如果沒有例外則會引發 ``ValueError``。"

#: ../../library/pdb.rst:183
msgid "Support for exception objects was added."
msgstr "新增對例外物件的支援。"

#: ../../library/pdb.rst:188
msgid ""
"Enter post-mortem debugging of the exception found in :data:`sys.last_exc`."
msgstr "進入在 :data:`sys.last_exc` 中發現的例外的事後偵錯。"

#: ../../library/pdb.rst:192
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for instantiating "
"the :class:`Pdb` class and calling the method of the same name.  If you want "
"to access further features, you have to do this yourself:"
msgstr ""
"``run*`` 函式和 :func:`set_trace` 都是別名，用於實例化 "
"(instantiate) :class:`Pdb` 類別並呼叫同名方法。如果要使用更多功能，則必須自己"
"執行以下操作："

#: ../../library/pdb.rst:199
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` 是偵錯器類別。"

#: ../../library/pdb.rst:201
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"*completekey*、*stdin* 與 *stdout* 引數會被傳到底層的 :class:`cmd.Cmd` 類別；"
"請於該文件閱讀相關敘述。"

#: ../../library/pdb.rst:204
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module name "
"patterns.  The debugger will not step into frames that originate in a module "
"that matches one of these patterns. [1]_"
msgstr ""
"如果給定 *skip* 引數，則它必須是一個給出 glob 樣式之模組名稱的疊代器。如果遇"
"到匹配這些樣式的模組，偵錯器將不會進入來自該模組的 frame。 [1]_"

#: ../../library/pdb.rst:208
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when the "
"user presses :kbd:`Ctrl-C` on the console) when you give "
"a :pdbcmd:`continue` command. This allows you to break into the debugger "
"again by pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT "
"handler, set *nosigint* to true."
msgstr ""
"預設情況下，當你發出 :pdbcmd:`continue` 命令時，Pdb 會為 SIGINT 訊號（即使用"
"者在控制台上按下 :kbd:`Ctrl-C` 時會發送的訊號）設定一個處理程式 (handler)，這"
"允許你透過按下 :kbd:`Ctrl-C` 再次切入偵錯器。如果你希望 Pdb 不影響到 SIGINT "
"處理程式，請將 *nosigint* 設定為 true。"

#: ../../library/pdb.rst:213
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will "
"load .pdbrc files from the filesystem."
msgstr "*readrc* 引數預設為 true，它控制 Pdb 是否從檔案系統載入 .pdbrc 檔案。"

#: ../../library/pdb.rst:216
msgid "Example call to enable tracing with *skip*::"
msgstr "啟用追蹤 (tracing) 且帶有 *skip* 引數的呼叫示範： ::"

#: ../../library/pdb.rst:218
msgid "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"
msgstr "import pdb; pdb.Pdb(skip=['django.*']).set_trace()"

#: ../../library/pdb.rst:220
msgid ""
"Raises an :ref:`auditing event <auditing>` ``pdb.Pdb`` with no arguments."
msgstr ""
"不帶引數地引發一個\\ :ref:`稽核事件 (auditing event) <auditing>` "
"``pdb.Pdb``。"

#: ../../library/pdb.rst:222
msgid "Added the *skip* parameter."
msgstr "新增了 *skip* 參數。"

#: ../../library/pdb.rst:225
msgid ""
"Added the *nosigint* parameter. Previously, a SIGINT handler was never set "
"by Pdb."
msgstr "新增了 *nosigint* 參數。以前 SIGINT 處理程式從未被 Pdb 設定過。"

#: ../../library/pdb.rst:229
msgid "The *readrc* argument."
msgstr "*readrc* 引數。"

#: ../../library/pdb.rst:237
msgid "See the documentation for the functions explained above."
msgstr "請見上面關於這些函式的文件說明。"

#: ../../library/pdb.rst:243
msgid "Debugger Commands"
msgstr "偵錯器命令"

#: ../../library/pdb.rst:245
msgid ""
"The commands recognized by the debugger are listed below.  Most commands can "
"be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` means "
"that either ``h`` or ``help`` can be used to enter the help command (but not "
"``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  Arguments to "
"commands must be separated by whitespace (spaces or tabs).  Optional "
"arguments are enclosed in square brackets (``[]``) in the command syntax; "
"the square brackets must not be typed.  Alternatives in the command syntax "
"are separated by a vertical bar (``|``)."
msgstr ""
"下方列出的是偵錯器能認得的命令。如下所示，大多數命令可以縮寫為一個或兩個字"
"母。如 ``h(elp)`` 表示可以輸入 ``h`` 或 ``help`` 來輸入幫助命令（但不能輸入 "
"``he`` 或 ``hel``，也不能是 ``H`` 或 ``Help`` 或 ``HELP``）。命令的引數必須用"
"空格（空格符 (spaces) 或製表符 (tabs)）分隔。在命令語法中，可選引數被括在方括"
"號 (``[]``) 中；使用時請勿輸入方括號。命令語法中的選擇項由豎線 (``|``) 分隔。"

#: ../../library/pdb.rst:254
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if the "
"last command was a :pdbcmd:`list` command, the next 11 lines are listed."
msgstr ""
"輸入一個空白列 (blank line) 將重複上次輸入的命令。例外：如果上一個命令"
"是 :pdbcmd:`list` 命令，則會列出接下來的 11 列。"

#: ../../library/pdb.rst:257
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged.  "
"Python statements can also be prefixed with an exclamation point (``!``).  "
"This is a powerful way to inspect the program being debugged; it is even "
"possible to change a variable or call a function.  When an exception occurs "
"in such a statement, the exception name is printed but the debugger's state "
"is not changed."
msgstr ""
"偵錯器無法識別的命令將被認為是 Python 陳述式，並以正在偵錯的程式之情境來執"
"行。Python 陳述式也可以用驚嘆號 (``!``) 作為前綴，這是檢視正在偵錯之程式的強"
"大方法，甚至可以修改變數或呼叫函式。當此類陳述式發生例外，將印出例外名稱，但"
"偵錯器的狀態不會改變。"

#: ../../library/pdb.rst:265
msgid ""
"Expressions/Statements whose prefix is a pdb command are now correctly "
"identified and executed."
msgstr "現在可以正確辨識並執行前綴為 pdb 命令的運算式/陳述式。"

#: ../../library/pdb.rst:269
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can have "
"parameters which allows one a certain level of adaptability to the context "
"under examination."
msgstr ""
"偵錯器有支援設定\\ :ref:`別名 <debugger-aliases>`。別名可以有參數，使得偵錯器"
"對被檢查的情境有一定程度的適應性。"

#: ../../library/pdb.rst:273
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  (A "
"single ``;`` is not used as it is the separator for multiple commands in a "
"line that is passed to the Python parser.)  No intelligence is applied to "
"separating the commands; the input is split at the first ``;;`` pair, even "
"if it is in the middle of a quoted string. A workaround for strings with "
"double semicolons is to use implicit string concatenation ``';'';'`` or ``\";"
"\"\";\"``."
msgstr ""
"在一列中可以輸入多個以 ``;;`` 分隔的命令。（不能使用單個 ``;``，因為它用於分"
"隔傳遞給 Python 剖析器一列中的多個命令。）切分命令沒運用什麼高深的方式；輸入"
"總是在第一處 ``;;`` 被切分開，即使它位於引號內的字串之中。對於具有雙分號字串"
"的一個變通解法，是使用隱式字串連接 ``';'';'`` 或 ``\";\"\";\"``。"

#: ../../library/pdb.rst:280
msgid ""
"To set a temporary global variable, use a *convenience variable*. A "
"*convenience variable* is a variable whose name starts with ``$``.  For "
"example, ``$foo = 1`` sets a global variable ``$foo`` which you can use in "
"the debugger session.  The *convenience variables* are cleared when the "
"program resumes execution so it's less likely to interfere with your program "
"compared to using normal variables like ``foo = 1``."
msgstr ""
"要設定臨時全域變數，請使用\\ *便利變數 (convenience variable)*。*便利變數*\\ "
"是名稱以 ``$`` 開頭的變數。例如 ``$foo = 1`` 會設定一個全域變數 ``$foo``，你"
"可以在偵錯器會話 (debugger session) 中使用它。當程式恢復執行時，*便利變數*\\ "
"將被清除，因此與使用 ``foo = 1`` 等普通變數相比，它不太會去干擾你的程式。"

#: ../../library/pdb.rst:287
msgid "There are three preset *convenience variables*:"
msgstr "共有三個預先設定的\\ *便利變數*："

#: ../../library/pdb.rst:289
msgid "``$_frame``: the current frame you are debugging"
msgstr "``$_frame``：當前正在偵錯的 frame"

#: ../../library/pdb.rst:290
msgid "``$_retval``: the return value if the frame is returning"
msgstr "``$_retval``：frame 回傳時的回傳值"

#: ../../library/pdb.rst:291
msgid "``$_exception``: the exception if the frame is raising an exception"
msgstr "``$_exception``：frame 引發例外時的例外"

#: ../../library/pdb.rst:295
msgid "Added the *convenience variable* feature."
msgstr "新增了\\ *便利變數*\\ 功能。"

#: ../../library/pdb.rst:301
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read with ``'utf-8'`` encoding and executed as if "
"it had been typed at the debugger prompt, with the exception that empty "
"lines and lines starting with ``#`` are ignored.  This is particularly "
"useful for aliases.  If both files exist, the one in the home directory is "
"read first and aliases defined there can be overridden by the local file."
msgstr ""
"如果 :file:`.pdbrc` 檔案存在於使用者的家目錄或當前目錄中，則會使用 "
"``'utf-8'`` 編碼讀取並執行該檔案，就像在偵錯器提示字元下鍵入該檔案一樣，除了"
"空列和以 ``#`` 開頭的列會被忽略之外。這對於別名設定特別有用。如果兩個檔案都存"
"在，則先讀取家目錄中的檔案，且定義於其中的別名可以被本地檔案覆蓋。"

#: ../../library/pdb.rst:308
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such "
"as :pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` 現在可以包含繼續偵錯的命令，如 :pdbcmd:`continue` "
"或 :pdbcmd:`next`。以前檔案中的這些命令是無效的。"

#: ../../library/pdb.rst:313
msgid ""
":file:`.pdbrc` is now read with ``'utf-8'`` encoding. Previously, it was "
"read with the system locale encoding."
msgstr ""
":file:`.pdbrc` 現在使用 ``'utf-8'`` 編碼讀取。以前它是使用系統區域設定編碼讀"
"取的。"

#: ../../library/pdb.rst:320
msgid ""
"Without argument, print the list of available commands.  With a *command* as "
"argument, print help about that command.  ``help pdb`` displays the full "
"documentation (the docstring of the :mod:`pdb` module).  Since the *command* "
"argument must be an identifier, ``help exec`` must be entered to get help on "
"the ``!`` command."
msgstr ""
"如不帶引數，印出可用的命令列表。引數為 *command* 時，印出有關該命令的幫助訊"
"息，``help pdb`` 會顯示完整文件（即 :mod:`pdb` 模組的說明字串 (docstring)）。"
"由於 *command* 引數必須是一個識別字 (identifier)，若要獲取 ``!`` 命令的幫助訊"
"息則必須輸入 ``help exec``。"

#: ../../library/pdb.rst:328
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  An arrow "
"(``>``) indicates the current frame, which determines the context of most "
"commands."
msgstr ""
"印出 stack trace，最新的 frame 會位於底部。箭頭（``>``）表示當前的 frame，它"
"也決定了大多數命令的情境。"

#: ../../library/pdb.rst:333
msgid ""
"Move the current frame *count* (default one) levels down in the stack trace "
"(to a newer frame)."
msgstr ""
"在 stack trace 中，將當前 frame 向下移動 *count* 級（預設為 1 級，移往較新的 "
"frame）。"

#: ../../library/pdb.rst:338
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace "
"(to an older frame)."
msgstr ""
"在 stack trace 中，將當前 frame 向上移動 *count* 級（預設為 1 級，移向較舊的 "
"frame）。"

#: ../../library/pdb.rst:343
msgid ""
"With a *lineno* argument, set a break at line *lineno* in the current file. "
"The line number may be prefixed with a *filename* and a colon, to specify a "
"breakpoint in another file (possibly one that hasn't been loaded yet).  The "
"file is searched on :data:`sys.path`.  Accepatable forms of *filename* are "
"``/abspath/to/file.py``, ``relpath/file.py``, ``module`` and "
"``package.module``."
msgstr ""
"如帶有 *lineno* 引數，則在目前檔案中的 *lineno* 列處設定中斷。列號可以以 "
"*filename* 和冒號為前綴，以指定另一個檔案（可能是尚未載入的檔案）中的斷點。該"
"檔案會在 :data:`sys.path` 上搜尋。可接受的 *filename* 形式為 ``/abspath/to/"
"file.py``、``relpath/file.py``、``module`` 和 ``package.module``。"

#: ../../library/pdb.rst:350
msgid ""
"With a *function* argument, set a break at the first executable statement "
"within that function. *function* can be any expression that evaluates to a "
"function in the current namespace."
msgstr ""
"如帶有 *function* 引數，在該函式內的第一個可執行陳述式處設定中斷。*function* "
"可以是任何其求值結果為目前命名空間中函式的運算式。"

#: ../../library/pdb.rst:354
msgid ""
"If a second argument is present, it is an expression which must evaluate to "
"true before the breakpoint is honored."
msgstr "如果第二個引數存在，它是一個運算式，在斷點生效前其必須求值為 true"

#: ../../library/pdb.rst:357
msgid ""
"Without argument, list all breaks, including for each breakpoint, the number "
"of times that breakpoint has been hit, the current ignore count, and the "
"associated condition if any."
msgstr ""
"如果不帶引數執行會列出所有斷點資訊，包括每個斷點、命中該斷點的次數、當前的忽"
"略次數以及關聯的條件（如存在）。"

#: ../../library/pdb.rst:361
msgid ""
"Each breakpoint is assigned a number to which all the other breakpoint "
"commands refer."
msgstr "每個斷點都有賦予一個編號，所有其他斷點命令都參照該編號。"

#: ../../library/pdb.rst:366
msgid ""
"Temporary breakpoint, which is removed automatically when it is first hit. "
"The arguments are the same as for :pdbcmd:`break`."
msgstr ""
"臨時斷點，在第一次遇見時會自動被刪除。它的引數與 :pdbcmd:`break` 相同。"

#: ../../library/pdb.rst:371
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this line. "
"With a space separated list of breakpoint numbers, clear those breakpoints. "
"Without argument, clear all breaks (but first ask confirmation)."
msgstr ""
"如帶有 *filename:lineno* 引數，則清除此列上的所有斷點。如果引數是空格分隔的斷"
"點編號列表，則清除這些斷點。如果不帶引數則清除所有斷點（但會先提示確認）。"

#: ../../library/pdb.rst:377
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to stop "
"execution, but unlike clearing a breakpoint, it remains in the list of "
"breakpoints and can be (re-)enabled."
msgstr ""
"停用斷點，斷點以空格分隔的斷點編號列表來給定。停用斷點表示它不會導致程式停止"
"執行，但是與清除斷點不同，停用的斷點將保留在斷點列表中並且可以（重新）啟用。"

#: ../../library/pdb.rst:384
msgid "Enable the breakpoints specified."
msgstr "啟用指定的斷點。"

#: ../../library/pdb.rst:388
msgid ""
"Set the ignore count for the given breakpoint number.  If *count* is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when the "
"ignore count is zero.  When non-zero, the *count* is decremented each time "
"the breakpoint is reached and the breakpoint is not disabled and any "
"associated condition evaluates to true."
msgstr ""
"為給定的斷點編號設定忽略計數。如果省略 *count* 則忽略計數設定為 0。當忽略計數"
"為 0 時，斷點將變為有效狀態。當非 0 時，每次到達斷點，且斷點沒有被禁用，且任"
"何關聯的條件被求值為 true，則 *count* 就會遞減。"

#: ../../library/pdb.rst:396
msgid ""
"Set a new *condition* for the breakpoint, an expression which must evaluate "
"to true before the breakpoint is honored.  If *condition* is absent, any "
"existing condition is removed; i.e., the breakpoint is made unconditional."
msgstr ""
"為斷點設定一個新 *condition*，為一個運算式，且其求值結果為 true 時斷點才會起"
"作用。如果沒有給定 *condition*，則刪除任何現有條件，也就是不為斷點設定條件。"

#: ../../library/pdb.rst:402
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The commands "
"themselves appear on the following lines.  Type a line containing just "
"``end`` to terminate the commands. An example::"
msgstr ""
"為編號是 *bpnumber* 的斷點指定一系列命令。命令內容出現在後續的幾列中。輸入僅"
"包含 ``end`` 的一列來結束命令列表。例如： ::"

#: ../../library/pdb.rst:406
msgid ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"
msgstr ""
"(Pdb) commands 1\n"
"(com) p some_variable\n"
"(com) end\n"
"(Pdb)"

#: ../../library/pdb.rst:411
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it "
"immediately with ``end``; that is, give no commands."
msgstr ""
"要刪除斷點上的所有命令，請輸入 ``commands`` 並立即以 ``end`` 結尾，也就是不指"
"定任何命令。"

#: ../../library/pdb.rst:414
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint set."
msgstr "不帶有 *bpnumber* 引數則 ``commands`` 會關聯到上一個設定的斷點。"

#: ../../library/pdb.rst:416
msgid ""
"You can use breakpoint commands to start your program up again.  Simply use "
"the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other command that "
"resumes execution."
msgstr ""
"可以使用斷點命令來重新啟動程式，只需使用 :pdbcmd:`continue` "
"或 :pdbcmd:`step` 命令，或其他可以繼續執行程式的命令。"

#: ../../library/pdb.rst:420
msgid ""
"Specifying any command resuming execution "
"(currently :pdbcmd:`continue`, :pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`jump`, :pdbcmd:`quit` "
"and their abbreviations) terminates the command list (as if that command was "
"immediately followed by end). This is because any time you resume execution "
"(even with a simple next or step), you may encounter another breakpoint—"
"which could have its own command list, leading to ambiguities about which "
"list to execute."
msgstr ""
"如果指定了某個繼續執行程式的命令（目前包"
"括 :pdbcmd:`continue`、:pdbcmd:`step`、:pdbcmd:`next`、:pdbcmd:`return`、:pdbcmd:`jump`、:pdbcmd:`quit` "
"及它們的縮寫）將終止命令列表（就像該命令後馬上跟著 end）。因為在任何時候繼續"
"執行下去（即使是簡單的 next 或 step），都可能會遇到另一個斷點，該斷點可能具有"
"自己的命令列表，這會導致無法確定要執行哪個列表。"

#: ../../library/pdb.rst:429
msgid ""
"If you use the ``silent`` command in the command list, the usual message "
"about stopping at a breakpoint is not printed.  This may be desirable for "
"breakpoints that are to print a specific message and then continue.  If none "
"of the other commands print anything, you see no sign that the breakpoint "
"was reached."
msgstr ""
"如果你在命令列表中使用 ``silent`` 命令，則平常會有的那些關於停止於斷點處的訊"
"息就不會印出。對於要印出特定訊息再繼續的斷點來說，這可能會是需要的功能。如果"
"其他命令都沒有印出任何內容，那你就看不到已到達斷點的跡象。"

#: ../../library/pdb.rst:436
msgid ""
"Execute the current line, stop at the first possible occasion (either in a "
"function that is called or on the next line in the current function)."
msgstr ""
"執行當前列，在第一個可以停止的位置（在被呼叫的函式內部或在當前函式的下一列）"
"停止。"

#: ../../library/pdb.rst:441
msgid ""
"Continue execution until the next line in the current function is reached or "
"it returns.  (The difference between :pdbcmd:`next` and :pdbcmd:`step` is "
"that :pdbcmd:`step` stops inside a called function, while :pdbcmd:`next` "
"executes called functions at (nearly) full speed, only stopping at the next "
"line in the current function.)"
msgstr ""
"繼續執行，直至執行到當前函式的下一列或者當前函式回傳為止。（:pdbcmd:`next` "
"和 :pdbcmd:`step` 之間的區別在於 :pdbcmd:`step` 會在被呼叫函式的內部停止、"
"而 :pdbcmd:`next`\\ （幾乎）全速執行被呼叫的函式，並僅在當前函式的下一列停"
"止。）"

#: ../../library/pdb.rst:449
msgid ""
"Without argument, continue execution until the line with a number greater "
"than the current one is reached."
msgstr "如果不帶引數則繼續執行，直到列號比當前的列大時停止。"

#: ../../library/pdb.rst:452
msgid ""
"With *lineno*, continue execution until a line with a number greater or "
"equal to *lineno* is reached.  In both cases, also stop when the current "
"frame returns."
msgstr ""
"如帶有 *lineno* 則繼續執行，直到到達列號大於或等於 *lineno* 的那一列。在這兩"
"種情況下，當前 frame 回傳時也會停止。"

#: ../../library/pdb.rst:456
msgid "Allow giving an explicit line number."
msgstr "允許明確給定一個列號。"

#: ../../library/pdb.rst:461
msgid "Continue execution until the current function returns."
msgstr "繼續執行，直到目前的函式回傳。"

#: ../../library/pdb.rst:465
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr "繼續執行，除非遇到斷點才停下來。"

#: ../../library/pdb.rst:469
msgid ""
"Set the next line that will be executed.  Only available in the bottom-most "
"frame.  This lets you jump back and execute code again, or jump forward to "
"skip code that you don't want to run."
msgstr ""
"設定即將執行的下一列，僅可用於堆疊中最底部的 frame。這讓你可以跳回去並再次執"
"行程式碼，或者往前跳以跳過不想執行的程式碼。"

#: ../../library/pdb.rst:473
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is not "
"possible to jump into the middle of a :keyword:`for` loop or out of "
"a :keyword:`finally` clause."
msgstr ""
"需要注意的是，不是所有的跳轉都是被允許的 -- 例如不能跳轉到 :keyword:`for` 迴"
"圈的中間或跳出 :keyword:`finally` 子句。"

#: ../../library/pdb.rst:479
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list 11 "
"lines around at that line.  With two arguments, list the given range; if the "
"second argument is less than the first, it is interpreted as a count."
msgstr ""
"列出當前檔案的原始碼。如果不帶引數，則列出當前列周圍的 11 列，或繼續先前的列"
"表操作。如果用 ``.`` 作為引數，則列出當前列周圍的 11 列。如果帶有一個引數，則"
"列出那一列周圍的 11 列。如果帶有兩個引數，則列出給定範圍中的程式碼；如果第二"
"個引數小於第一個引數，則將其直譯為要列出的列數。"

#: ../../library/pdb.rst:485
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the current "
"line."
msgstr ""
"當前 frame 中的當前列會用 ``->`` 標記出來。如果正在偵錯一個例外，且引發或傳遞"
"該例外的那一列不是當前列，則會用 ``>>`` 來標記該列。"

#: ../../library/pdb.rst:490
msgid "Added the ``>>`` marker."
msgstr "新增了 ``>>`` 標記。"

#: ../../library/pdb.rst:495
msgid ""
"List all source code for the current function or frame.  Interesting lines "
"are marked as for :pdbcmd:`list`."
msgstr ""
"列出當前函式或 frame 的所有原始碼。相關列的標記方式與 :pdbcmd:`list` 相同。"

#: ../../library/pdb.rst:502
msgid "Print the arguments of the current function and their current values."
msgstr "印出當前函式的引數及它們當前的值。"

#: ../../library/pdb.rst:506
msgid "Evaluate *expression* in the current context and print its value."
msgstr "在當前情境中為 *expression* 求值並印出其值。"

#: ../../library/pdb.rst:510
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"也可以使用 ``print()``，但它不是一個偵錯器命令 --- 它會執行 "
"Python :func:`print` 函式。"

#: ../../library/pdb.rst:516
msgid ""
"Like the :pdbcmd:`p` command, except the value of *expression* is pretty-"
"printed using the :mod:`pprint` module."
msgstr ""
"與 :pdbcmd:`p` 命令類似，除了 *expression* 的值是使用 :mod:`pprint` 模組美化"
"後印出來的。"

#: ../../library/pdb.rst:521
msgid "Print the type of *expression*."
msgstr "印出 *expression* 的型別。"

#: ../../library/pdb.rst:525
msgid "Try to get source code of *expression* and display it."
msgstr "嘗試獲取 *expression* 的原始碼並顯示它。"

#: ../../library/pdb.rst:531
msgid ""
"Display the value of *expression* if it changed, each time execution stops "
"in the current frame."
msgstr "每次在當前 frame 中停止執行時，顯示 *expression* 的值（如果有變更）。"

#: ../../library/pdb.rst:534
msgid ""
"Without *expression*, list all display expressions for the current frame."
msgstr "如果不帶有 *expression*，則列出當前 frame 的所有運算式。"

#: ../../library/pdb.rst:538
msgid ""
"Display evaluates *expression* and compares to the result of the previous "
"evaluation of *expression*, so when the result is mutable, display may not "
"be able to pick up the changes."
msgstr ""
"display 會對 *expression* 求值並將結果與之前 *expression* 的求值結果進行比"
"較，因此當結果可變時，display 可能無法獲取其變更。"

#: ../../library/pdb.rst:542 ../../library/pdb.rst:692
msgid "Example::"
msgstr "範例如下： ::"

#: ../../library/pdb.rst:544
msgid ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"
msgstr ""
"lst = []\n"
"breakpoint()\n"
"pass\n"
"lst.append(1)\n"
"print(lst)"

#: ../../library/pdb.rst:550
msgid ""
"Display won't realize ``lst`` has been changed because the result of "
"evaluation is modified in place by ``lst.append(1)`` before being compared::"
msgstr ""
"display 不會意識到 ``lst`` 已更改，因為其求值結果在比較之前已被 "
"``lst.append(1)`` 原地 (in place) 修改： ::"

#: ../../library/pdb.rst:553
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst\n"
"display lst: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"(Pdb)"

#: ../../library/pdb.rst:565
msgid "You can do some tricks with copy mechanism to make it work::"
msgstr "你可以運用複製機制的一些技巧來使其能夠運作： ::"

#: ../../library/pdb.rst:567
msgid ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"
msgstr ""
"> example.py(3)<module>()\n"
"-> pass\n"
"(Pdb) display lst[:]\n"
"display lst[:]: []\n"
"(Pdb) n\n"
"> example.py(4)<module>()\n"
"-> lst.append(1)\n"
"(Pdb) n\n"
"> example.py(5)<module>()\n"
"-> print(lst)\n"
"display lst[:]: [1]  [old: []]\n"
"(Pdb)"

#: ../../library/pdb.rst:584
msgid ""
"Do not display *expression* anymore in the current frame.  Without "
"*expression*, clear all display expressions for the current frame."
msgstr ""
"不再顯示當前 frame 中的 *expression*。如果不帶有 *expression*，則清除當前 "
"frame 的所有顯示運算式。"

#: ../../library/pdb.rst:591
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) in a new "
"global namespace initialised from the local and global namespaces for the "
"current scope. Use ``exit()`` or ``quit()`` to exit the interpreter and "
"return to the debugger."
msgstr ""
"在從目前作用域的區域和全域命名空間初始化的新全域命名空間中啟動互動式直譯器"
"（使用 :mod:`code` 模組）。可使用 ``exit()`` 或 ``quit()`` 退出直譯器並回到偵"
"錯器。"

#: ../../library/pdb.rst:598
msgid ""
"As ``interact`` creates a new dedicated namespace for code execution, "
"assignments to variables will not affect the original namespaces. However, "
"modifications to any referenced mutable objects will be reflected in the "
"original namespaces as usual."
msgstr ""
"由於 ``interact`` 為程式碼執行建立了一個新的專用命名空間，因此變數的賦值不會"
"影響原始命名空間，但是對任何被參照的可變物件的修改將像往常一樣反映在原始命名"
"空間中。"

#: ../../library/pdb.rst:605
msgid ""
"``exit()`` and ``quit()`` can be used to exit the :pdbcmd:`interact` command."
msgstr "``exit()`` 和 ``quit()`` 可用來退出 :pdbcmd:`interact` 命令。"

#: ../../library/pdb.rst:609
msgid ""
":pdbcmd:`interact` directs its output to the debugger's output channel "
"rather than :data:`sys.stderr`."
msgstr ""
":pdbcmd:`interact` 將其輸出導向到偵錯器的輸出通道 (output channel)，而不"
"是 :data:`sys.stderr`。"

#: ../../library/pdb.rst:617
msgid ""
"Create an alias called *name* that executes *command*.  The *command* must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, ... and ``%9``, while ``%*`` is replaced by all the "
"parameters. If *command* is omitted, the current alias for *name* is shown. "
"If no arguments are given, all aliases are listed."
msgstr ""
"建立一個名為 *name* 的別名，用於執行 *command*。*command* *不得*\\ 用引號包起"
"來。可被替換的參數要用 ``%1``、``%2``、 ... 和 ``%9`` 標示，而 ``%*`` 則被所"
"有參數替換。如果省略 *command*，則顯示 *name* 的目前別名。如果未給定引數，則"
"列出所有別名。"

#: ../../library/pdb.rst:623
msgid ""
"Aliases may be nested and can contain anything that can be legally typed at "
"the pdb prompt.  Note that internal pdb commands *can* be overridden by "
"aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; all "
"other words in the line are left alone."
msgstr ""
"巢狀別名是允許的，且可包含能在 pdb 提示字元下合法輸入的任何內容。請注意，內"
"部 pdb 命令\\ *可以*\\ 被別名所覆蓋。這樣的命令在別名被移除前都將被隱藏。別名"
"會遞迴地應用到命令列的第一個單詞；該列內的其他單詞則不會受影響。"

#: ../../library/pdb.rst:629
msgid ""
"As an example, here are two useful aliases (especially when placed in "
"the :file:`.pdbrc` file)::"
msgstr ""
"作為範例，這裡列出了兩個有用的別名（特別是放在 :file:`.pdbrc` 檔案中時）： ::"

#: ../../library/pdb.rst:632
msgid ""
"# Print instance variables (usage \"pi classInst\")\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# Print instance variables in self\n"
"alias ps pi self"
msgstr ""
"# 印出實例變數（用法如 \"pi classInst\"）\n"
"alias pi for k in %1.__dict__.keys(): print(f\"%1.{k} = {%1.__dict__[k]}\")\n"
"# 印出 self 中的實例變數\n"
"alias ps pi self"

#: ../../library/pdb.rst:639
msgid "Delete the specified alias *name*."
msgstr "刪除指定的別名 *name*。"

#: ../../library/pdb.rst:643
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command, e.g.:"
msgstr ""
"在當前 stack frame 的情境中執行（單列）\\ *statement*。除非陳述式的第一個單詞"
"類似於偵錯器命令，否則可以省略驚嘆號，例如："

#: ../../library/pdb.rst:647
msgid ""
"(Pdb) ! n=42\n"
"(Pdb)"
msgstr ""
"(Pdb) ! n=42\n"
"(Pdb)"

#: ../../library/pdb.rst:652
msgid ""
"To set a global variable, you can prefix the assignment command with "
"a :keyword:`global` statement on the same line, e.g.:"
msgstr ""
"要設定全域變數，你可以在同一列的賦值命令前面加上 :keyword:`global` 陳述式，例"
"如："

#: ../../library/pdb.rst:655
msgid ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"
msgstr ""
"(Pdb) global list_options; list_options = ['-l']\n"
"(Pdb)"

#: ../../library/pdb.rst:663
msgid ""
"Restart the debugged Python program.  If *args* is supplied, it is split "
"with :mod:`shlex` and the result is used as the new :data:`sys.argv`. "
"History, breakpoints, actions and debugger options are "
"preserved. :pdbcmd:`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"重新啟動已偵錯完畢的 Python 程式。如果提供了 *args*，它將以 :mod:`shlex` 分"
"割，並將結果用作新的 :data:`sys.argv`。歷史記錄、斷點、操作和偵錯器選項均會被"
"保留。:pdbcmd:`restart` 是 :pdbcmd:`run` 的別名。"

#: ../../library/pdb.rst:670
msgid "Quit from the debugger.  The program being executed is aborted."
msgstr "離開偵錯器，執行中的程式會被中止。"

#: ../../library/pdb.rst:674
msgid ""
"Enter a recursive debugger that steps through *code* (which is an arbitrary "
"expression or statement to be executed in the current environment)."
msgstr ""
"進入一個遞迴偵錯器，逐步執行 *code*\\ （這是要在當前環境中執行的任意運算式或"
"陳述式）。"

#: ../../library/pdb.rst:680
msgid "Print the return value for the last return of the current function."
msgstr "印出當前函式最後一次回傳的回傳值。"

#: ../../library/pdb.rst:684
msgid "List or jump between chained exceptions."
msgstr "列出鏈接例外 (chained exceptions)，或在其間跳轉。"

#: ../../library/pdb.rst:686
msgid ""
"When using ``pdb.pm()``  or ``Pdb.post_mortem(...)`` with a chained "
"exception instead of a traceback, it allows the user to move between the "
"chained exceptions using ``exceptions`` command to list exceptions, and "
"``exception <number>`` to switch to that exception."
msgstr ""
"當使用 ``pdb.pm()`` 或 ``Pdb.post_mortem(...)`` 於鏈接例外而不是回溯時，它允"
"許使用者在鏈接例外之間移動，使用 ``exceptions`` 命令以列出例外，並使用 "
"``exception <number>`` 切換到該例外。"

#: ../../library/pdb.rst:694
msgid ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"
msgstr ""
"def out():\n"
"    try:\n"
"        middle()\n"
"    except Exception as e:\n"
"        raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"def middle():\n"
"    try:\n"
"        return inner(0)\n"
"    except Exception as e:\n"
"        raise ValueError(\"Middle fail\")\n"
"\n"
"def inner(x):\n"
"    1 / x\n"
"\n"
" out()"

#: ../../library/pdb.rst:711
msgid "calling ``pdb.pm()`` will allow to move between exceptions::"
msgstr "呼叫 ``pdb.pm()`` 將允許在例外之間移動： ::"

#: ../../library/pdb.rst:713
msgid ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"
msgstr ""
"> example.py(5)out()\n"
"-> raise ValueError(\"reraise middle() error\") from e\n"
"\n"
"(Pdb) exceptions\n"
"  0 ZeroDivisionError('division by zero')\n"
"  1 ValueError('Middle fail')\n"
"> 2 ValueError('reraise middle() error')\n"
"\n"
"(Pdb) exceptions 0\n"
"> example.py(16)inner()\n"
"-> 1 / x\n"
"\n"
"(Pdb) up\n"
"> example.py(10)middle()\n"
"-> return inner(0)"

#: ../../library/pdb.rst:732
msgid "Footnotes"
msgstr "註腳"

#: ../../library/pdb.rst:733
msgid ""
"Whether a frame is considered to originate in a certain module is determined "
"by the ``__name__`` in the frame globals."
msgstr ""
"一個 frame 是否會被認為源自特定模組是由該 frame 全域性變數中的 ``__name__`` "
"來決定的。"

#: ../../library/pdb.rst:11
msgid "debugging"
msgstr "debugging（偵錯）"

#: ../../library/pdb.rst:21
msgid "Pdb (class in pdb)"
msgstr "Pdb（pdb 中的類別）"

#: ../../library/pdb.rst:21
msgid "module"
msgstr "module（模組）"

#: ../../library/pdb.rst:21
msgid "bdb"
msgstr "bdb"

#: ../../library/pdb.rst:21
msgid "cmd"
msgstr "cmd"

#: ../../library/pdb.rst:297
msgid ".pdbrc"
msgstr ".pdbrc"

#: ../../library/pdb.rst:297
msgid "file"
msgstr "file（檔案）"

#: ../../library/pdb.rst:297
msgid "debugger"
msgstr "debugger（偵錯器）"

#: ../../library/pdb.rst:297
msgid "configuration"
msgstr "configuration（設定）"
